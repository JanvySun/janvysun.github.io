<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Python 进阶 | Janvy's blog</title><meta name="keywords" content="Python"><meta name="author" content="Janvy Sun"><meta name="copyright" content="Janvy Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。本文介绍 Python 的核心内容。"><meta property="og:type" content="article"><meta property="og:title" content="Python 进阶"><meta property="og:url" content="https://janvysun.github.io/python/8541a389-77d7-45ce-a30a-187778c6725a.html"><meta property="og:site_name" content="Janvy&#39;s blog"><meta property="og:description" content="Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。本文介绍 Python 的核心内容。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://janvysun.github.io/images/hexo.png"><meta property="article:published_time" content="2019-04-13T16:00:00.000Z"><meta property="article:modified_time" content="2019-04-13T16:00:00.000Z"><meta property="article:author" content="Janvy Sun"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://janvysun.github.io/images/hexo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://janvysun.github.io/python/8541a389-77d7-45ce-a30a-187778c6725a"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: [object Object]
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Python 进阶",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2019-04-14 00:00:00"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/hexo.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Janvy's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-04-13T16:00:00.000Z" title="发表于 2019-04-14 00:00:00">2019-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-04-13T16:00:00.000Z" title="更新于 2019-04-14 00:00:00">2019-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">42.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>165分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Python 进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。本文介绍 Python 的核心内容。</p><span id="more"></span><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><ul><li><p><strong>搜索顺序</strong><br>在基础篇中的模块导入有个搜索顺序，这个顺序是可以查看的<br>如果想查看这个搜索顺序，首先导入sys模块，这个模块中有个<strong>path</strong><br>这个值就是以列表形式保存了所有的搜索路径<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/usr/lib/python35.zip&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.5&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.5/plat-x86_64-linux-gnu&#x27;</span>, <span class="string">&#x27;/usr/lib/python3.5/lib-dynload&#x27;</span>, <span class="string">&#x27;/usr/local/lib/python3.5/dist-packages&#x27;</span>, <span class="string">&#x27;/usr/lib/python3/dist-packages&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这个搜索路径是有顺序的，按<strong>从上到下</strong>的顺序来搜索，最先搜索的是当前路径，然后依次往下搜索<br>既然这个sys.path是以列表的形式保存的，那么这个列表也是可以被<strong>增加和修改</strong>的，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">&#x27;/home/xxx&#x27;</span>)</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;/home/xxx&#x27;</span>) </span><br></pre></td></tr></table></figure><p>但是在执行的时候会这样，执行完毕后重新导入这个模块之后会恢复原样</p></li><li><p><strong>模块的重载</strong><br>在导入一个模块之后，程序仍在进行，如果对这个模块进行了修改那么在程序中是不会发生改动的。并且使用import也不能让模块重新导入。<br>这个时候需要重新加载模块，重新加载模块需要导入imp包中的reload模块<br>使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line">reload(需要重载的模块)</span><br></pre></td></tr></table></figure><p>例如我首先在test中写一个函数，然后在交互式界面中导入test模块执行函数打印1，然后修改函数中的打印值为2，重载模块，再调用模块中的打印函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> test <span class="keyword">as</span> t</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.test()</span><br><span class="line">----<span class="number">1</span>----</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(t)</span><br><span class="line">&lt;module <span class="string">&#x27;test&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/root/pythonSource/test.py&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.test()              </span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="is-和-x3D-x3D"><a href="#is-和-x3D-x3D" class="headerlink" title="is 和 &#x3D;&#x3D;"></a>is 和 &#x3D;&#x3D;</h3><p><code>is</code>和<code>==</code>是有区别的，其中<code>is</code>是比较2个引用是否指向了同一块内存空间，而<code>==</code>是比较两个对象是否相等<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>之中的a和b是指向2个引用，指向同一个列表，因此用<code>is</code>还是<code>==</code>返回的都是True<br>又如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>之中的 a 和 b 是分别创建了一个列表，所以这 2 者不是同一个列表，因此用 <code>is</code> 会返回 False，但由于两者的值是相等的，所以 <code>==</code> 返回的是 True</p><p>另外：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = -<span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = -<span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = -<span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = -<span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>从 -6~256 这些整数是固定空间的，不会重新去开辟新的空间。</p><p>因此用变量保存这些值的时候都是直接返回的引用，不会开辟新的空间然后返回引用。</p><p>总结：如果 <code>==</code> 返回的是 True，那么 <code>is</code> 返回的不一定是 True；如果 <code>is</code> 返回的是 True，那么 <code>==</code> 返回的一定的 True</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li><p><strong>浅拷贝</strong><br>浅拷贝是对于一个对象的顶层拷贝，也就是说浅拷贝只是拷贝了引用，并没有拷贝内容。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140023438544520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140023438544520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这就是一个浅拷贝，只是拷贝了引用，这两者还是指向同一内存，一个修改另一个会跟着修改</p></li><li><p><strong>深拷贝</strong><br>深拷贝是对于一个对象所有层次的拷贝，会<strong>递归拷贝</strong><br>想要进行深拷贝的时候需要导入一个<strong>copy模块</strong><br>这个模块中有个函数为<strong>deepcopy</strong>，就是用来进行深拷贝操作的函数。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [a,b]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>这里首先创建了a、b两个列表，然后创建一个列表c用来保存a、b两个引用。<br>之后深拷贝了列表c（里面的2个引用被递归进行深拷贝）给d。<br>之后给a列表添加了元素，这样保存a引用的c列表中的元素也会跟着改变，而进行了深拷贝的列表d中的元素就没有改变。<br>这里的c换成元组也是一样的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = (a,b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure></li><li><p><strong>copy</strong><br>copy这个函数也需要导入copy模块，这个函数也是一种<strong>浅拷贝</strong>，和引用赋值的区别为copy可以拷贝第一层的空间。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [a,b]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.copy(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">140417487393544</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(d)</span><br><span class="line"><span class="number">140417523625224</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>虽然用copy是重新开辟了一片空间，但是存放的仍然是a、b两个列表的引用，因此a、b改动的时候d还是会跟着改变，因此copy也是一种浅拷贝。<br>另外，copy对可变类型和不可变类型的拷贝也不相同，用copy拷贝可变类型会重新开辟空间；而对于不可变类型，copy是直接返回的引用。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140417486682888</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140417487526408</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.copy(c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">140417523595232</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(d)</span><br><span class="line"><span class="number">140417523595232</span></span><br></pre></td></tr></table></figure><p>字典是自带一个copy函数的，可以完成类似于copy的一个操作（不会递归拷贝），如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&quot;list&quot;</span>:a, <span class="string">&quot;age&quot;</span>:<span class="number">16</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = b.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">139654870186632</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">139654869678472</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;list&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;list&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="进制和位运算"><a href="#进制和位运算" class="headerlink" title="进制和位运算"></a>进制和位运算</h3><p>数据在机器中的存储是以二进制的方式存储的，关于进制这里不多谈。<br>计算机中的运算是以二进制方式进行的，因此有几个概念需要了解：<strong>原码、反码、补码</strong>。</p><blockquote><p>对于正数而言，原码、反码和补码都是相同的；<br>而对于负数而言，反码就是符号位（对于有符号数来说，最高为就是符号为，为0是正数，为1是负数）不变，其他为取反，补码就是反码+1。</p></blockquote><p>如果要让补码转化为原码，符号位不变，其余位取反+1即可<br><strong>注意：原码转补码和补码转原码是一样的方式，都是符号位不变，其余位取反再加1即可</strong><br>进制间转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#10进制转为2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line"><span class="comment">#2进制转为10进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&quot;1001&quot;</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">#10进制转为16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;0xa&#x27;</span></span><br><span class="line"><span class="comment">#16进制到10进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0xab&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">171</span></span><br><span class="line"><span class="comment">#16进制到2进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">0xa</span>)</span><br><span class="line"><span class="string">&#x27;0b1010&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment">#10进制到8进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">8</span>)</span><br><span class="line"><span class="string">&#x27;010&#x27;</span></span><br><span class="line"><span class="comment">#2进制到16进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0b1001</span>)</span><br><span class="line"><span class="string">&#x27;0x9&#x27;</span></span><br></pre></td></tr></table></figure><p>注意：计算机中的运算都是以<strong>补码</strong>来进行的，但是显示的结果是以<strong>原码</strong>的方式显示的。</p><p><strong>位运算</strong>是直接对二进制进行操作，这样做能省内存，效率也很高。</p><p>位运算分为以下几点：<code>按位与(&amp;)</code>、<code>按位或(|)</code>、<code>按位异或(^)</code>、<code>按位取反(~)</code>、<code>按位左移(&lt;&lt;)</code>、<code>按位右移(&gt;&gt;)</code>。</p><ul><li><strong>按位左移：各二进位全部左移n位,高位丢弃,低位补0</strong>，格式如下：<br><code>x &lt;&lt; n #将x的所有二进制位向左移n位</code><br><strong>注意：左移一位就是乘以2，左移n位就是乘以2的n次方，还有一点就是左移可能会改变一个数的正负性</strong></li><li><strong>按位右移：各二进位全部右移n位,保持符号位不变</strong>，格式如下：<br><code>x &gt;&gt; n #将x 的所有二进制为向右移n位</code><br><strong>和左移类似，右移一位是除以2，右移n位就是除以2的n次方</strong></li><li><strong>按位与：各二进制位依次比较，全1为1，否则为0，只有对应的两个二进位均为1时,结果位才为1,否则为0</strong>，格式如下：<br><code>x &amp; y</code></li><li><strong>按位或：有1就1只要对应的二个二进位有一个为1时,结果位就为1,否则为0</strong>，格式如下：<br><code>x | y</code></li><li><strong>按位异或：不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0</strong>，格式如下：<br><code>x ^ y</code></li><li><strong>取反：各二进制位依次取反，格式如下：</strong><br><code>~x</code><blockquote><p>如：<code>~9 = -10</code><br>解释：9的原码为00001001，正数原码和补码相同，因此实际存储的是9的补码也是这个。<br>将其进行取反操作得到11110110为操作之后的补码，然后将这个补码转为原码后为10001010，就是-10的原码。<br>因此<code>~9 = -10</code></p></blockquote></li></ul><h3 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h3><p>在一个类中，有如下几种命名<br><code>xx</code>: 公有变量<br><code>_x</code>: 单前置下划线,私有化属性或方法，<code>from SomeModule import *</code>禁止导入,类对象和子类可以访问<br><code>__xx</code>：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)<br><code>__xx__</code>:双前后下划线,用户名字空间的魔法对象或属性。例如:<code>__init__</code>, 不要自己发明这样的名字<br><code>xx_</code>:单后置下划线,用于避免与Python关键词的冲突，一般不建议这样做</p><p><strong>注意：在类中的私有属性看起来不能用，实际上是能用的。</strong><br>如在Test类中有个__num属性，它实际上是被改成了_Test__num这个名字。<br>所以看起来不能用，但是可以通过_Test__num来访问这个属性。<br>这在Python中称为名字重整(Name Mangling)，就是为了防止子类意外重写基类的方法或者属性</p><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>在一个类中有一些属性不想让外界轻易访问，则需要定义getter和setter方法，但是这样写，调用的时候是调用的方法。<br>而我们的目的是为了修改和得到属性的值，因此这样掉方法挺麻烦的。<br>这时候就可以用<strong>property</strong>让这个方法能像修改成员属性那样调用getter和setter方法。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMoney</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMoney</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error, 传入非整形参数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    money = <span class="built_in">property</span>(getMoney, setMoney)</span><br></pre></td></tr></table></figure><p>执行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Money()</span><br><span class="line">&gt;&gt;&gt; a.money</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a.money = 100</span><br><span class="line">&gt;&gt;&gt; a.money</span><br></pre></td></tr></table></figure><p>这样就可以通过property来达到类似调用属性的形式来调用方法</p><p>关于property还有一种玩法，就是<strong>装饰器</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line"><span class="meta">    @money.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error, 传入非整形参数&quot;</span>)</span><br></pre></td></tr></table></figure><p>定义函数的时候直接使用要调用的属性名即可，然后在getter方法前加上<code>@property</code>，在setter方法前加上<code>@属性名.setter</code>就行了，执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Money()</span><br><span class="line">&gt;&gt;&gt; a.money</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a.money = 100</span><br><span class="line">&gt;&gt;&gt; a.money</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; a.money = &quot;abc&quot;</span><br><span class="line">Error, 传入非整形参数</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。<br>但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？<br>这样就不必创建完整的list，从而节省大量的空间。<br>在Python中，这种一边循环一边计算的机制，称为**生成器(generator)**。<br>前面说过列表推导式，也叫列表生成式，如list &#x3D; [x for x in range(5)]，可以通过这个来生成一个列表，如果将列表生成式两端的”[]”变成”()”，那么这样就变成了一个生成器。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7f69169603b8</span>&gt;</span><br></pre></td></tr></table></figure><p>生成器需要用**next()**函数来一个一个打印其中的值，并且生成器是要一个值就给一个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>当没有值的时候还调用next函数就会出现异常。<br>当然，通常情况下我们不用next函数，而是直接通过for循环来迭代这个生成器，这样做就会在生成器没值的时候跳出循环而不会出现异常。</p><ul><li><strong>yield</strong><br>yield关键字是用来创建生成器的，当一个函数中使用了yield关键字的时候，那么就不能将这个函数当成一个普通的函数来处理，这个函数本质上是一个生成器了。<br>如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br></pre></td></tr></table></figure>打印结果如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator <span class="built_in">object</span> test at <span class="number">0x7f639ec47518</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(f)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: Done</span><br></pre></td></tr></table></figure>应用：斐波那契数列：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">count</span>):</span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">1</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br></pre></td></tr></table></figure>生成器有一个自带的函数为<code>__next__()</code>函数，和<code>next()</code>函数的效果是一样的<br>另外，生成器在生成一个值的时候是会停在yield语句这里的，等待下一个值的获取才会执行。<br>如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----1----&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----2----&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----3----&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----4----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br></pre></td></tr></table></figure>执行结果如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">1</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">4</span>----</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: Done</span><br></pre></td></tr></table></figure>生成器还带一个函数为**send()**函数，和next函数类似，不过send函数可以传值给生成器。<br>如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----1----&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----2----&quot;</span>)</span><br><span class="line">        temp = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(temp)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----3----&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----4----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br></pre></td></tr></table></figure>执行结果如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="literal">None</span>)  </span><br><span class="line">----<span class="number">1</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="string">&quot;hehe&quot;</span>)</span><br><span class="line">hehe</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">haha</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="string">&quot;heihei&quot;</span>)</span><br><span class="line">heihei</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="string">&quot;heihei&quot;</span>)</span><br><span class="line">heihei</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">2</span>----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.send(<span class="string">&quot;heihei&quot;</span>)</span><br><span class="line">heihei</span><br><span class="line">----<span class="number">3</span>----</span><br><span class="line">----<span class="number">4</span>----</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: Done</span><br></pre></td></tr></table></figure><strong>注意</strong>：第一次send的时候是不能传入值的，因为生成器刚开始还没有停在yield语句这里，使用send传入值是传入到yield那里，所以第一次需要让生成器停在yield语句这里才能使用send传值。<br>另外，send还可以传<code>None，f.send(None)和f.__next__()、next(f)</code>，其效果是一样的。<br><strong>总结</strong>：<br>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。<br>对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。<br>生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。<br>生成器的特点：<ol><li>节约内存</li><li>迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的</li></ol></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是访问集合元素的一种方式。<br>迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。<br>迭代器只能往前不会后退。</p><ul><li><p><strong>可迭代对象</strong><br>以直接作用于 for 循环的数据类型有以下几种：<br>一类是<strong>集合</strong>数据类型，如 list 、 tuple 、 dict 、 set 、 str 等；<br>一类是<strong>generator</strong>，包括<strong>生成器</strong>和<strong>带yield的generator function</strong>。<br>这些<strong>可以直接作用于for循环的对象</strong>统称为可迭代对象(Iterable)。<br>可以使用**isinstance()**函数判断一个对象是否是可迭代(Iterable)对象<br>Iterable需要<code>from collections import Iterable</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterable)  </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&quot;abc&quot;</span>, Iterable)  </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable)     </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)                      </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>迭代器</strong><br>**可以被next()函数调用并不断返回下一个值的对象称为迭代器(Iterator)<strong>。<br>可以使用</strong>isinstance()**判断一个对象是否是Iterator对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterator)                     </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterator)  </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&quot;abc&quot;</span>, Iterator)  </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterator)     </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>iter函数</strong><br>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。<br>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">iter</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x7f4f78d7ca58</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结：<br>1、凡是可作用于for循环的对象都是Iterable类型；<br>2、凡是可作用于next()函数的对象都是Iterator类型；<br>3、集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过 iter()函数获得一个Iterator对象。</p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为<strong>闭包</strong>。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---2---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(number + <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---3---&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> test_in</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">100</span>)</span><br><span class="line">---<span class="number">1</span>---</span><br><span class="line">---<span class="number">3</span>---</span><br><span class="line">&lt;function test.&lt;<span class="built_in">locals</span>&gt;.test_in at <span class="number">0x7f5861b9ca60</span>&gt;</span><br></pre></td></tr></table></figure><p>返回的结果是一个函数引用（类似于C语言中的函数指针）。<br>这个引用可以被调用，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = test(<span class="number">100</span>)</span><br><span class="line">---<span class="number">1</span>---</span><br><span class="line">---<span class="number">3</span>---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret()</span><br><span class="line">---<span class="number">2</span>---</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>闭包中还可以传递参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">k, b</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(k*x + b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> test_in</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = test(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret(<span class="number">5</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>这就是一个利用闭包计算y &#x3D; kx+b的例子</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题。<br>有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----inner----&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---f1---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---f2---&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = w1(f1)</span><br><span class="line">ret()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br><span class="line">ret = w1(f2)</span><br><span class="line">ret()</span><br></pre></td></tr></table></figure><p>首先创建一个闭包，然后调用这个闭包，传入我们要装饰的函数f1，之后执行那个闭包函数。<br>这样，那个被装饰的函数会被执行一遍，并且还能执行我们添加的装饰语句。<br>既然可以用ret来接收这个被装饰了的函数，那么能不能直接用要装饰的函数名来代替呢？<br>答案是可以的，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = w1(f1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line">----inner----</span><br><span class="line">---f1---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = w1(f2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line">----inner----</span><br><span class="line">---f2---</span><br></pre></td></tr></table></figure><p>其实装饰器就是完成这一步的功能<strong>原函数名 &#x3D; 装饰器(原函数引用)</strong><br>由此我们可以知道，装饰器就是一个闭包函数，它的用法就是在要被装饰的函数上一行加上<code>@装饰器</code>即可，实际上它完成的功能就是**原函数名 &#x3D; 装饰器(原函数引用)**这一操作。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----inner----&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---f1---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---f2---&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line">----inner----</span><br><span class="line">---f1---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line">----inner----</span><br><span class="line">---f2---</span><br></pre></td></tr></table></figure><p>由于装饰器就相当于做了：**原函数名 &#x3D; 装饰器(原函数引用)**这样的工作，那么在执行<code>@</code>语句的时候实际上会将装饰器函数的外部执行一遍。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---w1---&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner----&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---test---&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python3 test.py </span><br><span class="line">---w1---</span><br></pre></td></tr></table></figure><p>所以只要Python解释器执行了@这个代码，那么就会自动的进行装饰，而不是等到要调用的时候才去进行装饰</p><ul><li><p><strong>多个装饰器</strong><br>如果有多个装饰器的时候会怎么执行呢？<br>有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">makeBold</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;b&gt;&quot;</span>+fn()+<span class="string">&quot;&lt;/b&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeItalic</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---2---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;i&gt;&quot;</span>+fn()+<span class="string">&quot;&lt;/i&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line">    </span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---3---&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">---<span class="number">1</span>---</span><br><span class="line">---<span class="number">2</span>---</span><br><span class="line">---<span class="number">3</span>---</span><br><span class="line"><span class="string">&#x27;&lt;b&gt;&lt;i&gt;Hello World&lt;/i&gt;&lt;/b&gt;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>分析：首先执行的是makeBold，也就是最上面的装饰器，这个装饰器会将下面内容当成一个整体来执行，因此首先对test函数进行makeItalic的装饰，然后再进行makeBold的装饰。<br>所以调用test函数的时候会先打印1，然后打印2，最后打印3，返回的结果为最后的结果。</p></blockquote><p>我们可以在装饰器中的闭包函数之前加上打印语句来验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---w1---&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner1s----&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner1e----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">w2</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---w2---&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner2s----&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner2e----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="meta">@w2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---test---&quot;</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---w2---</span><br><span class="line">---w1---</span><br><span class="line">---inner1s----</span><br><span class="line">---inner2s----</span><br><span class="line">---test---</span><br><span class="line">---inner2e----</span><br><span class="line">---inner1e----</span><br></pre></td></tr></table></figure><p>由此可以看到，<strong>最里面的装饰器先执行，最外的装饰器先打印</strong></p></li><li><p><strong>装饰带参函数</strong><br>我们在闭包中了解到，闭包中是可以传参数的，因此我们装饰器中的闭包也是可以有参数的，那么我们就可以用装饰器来装饰带有参数的函数了。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">a,b</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner1s----&quot;</span>)</span><br><span class="line">        func(a,b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inner1e----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d+%d=%d&quot;</span> %(a,b,a+b))</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">---inner1s----</span><br><span class="line"><span class="number">10</span>+<span class="number">20</span>=<span class="number">30</span></span><br><span class="line">---inner1e----</span><br></pre></td></tr></table></figure><p>这样做的话就固定了参数个数，如果有多个函数并且各函数参数个数各不相同并且想用同一个装饰器的话该如何是好呢？我们之前学过不定长参数，用这个来接收参数再好不过了。<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inners----&quot;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---innere----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d+%d=%d&quot;</span> %(a,b,a+b))</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d+%d+%d=%d&quot;</span> %(a,b,c,a+b+c))</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">---inners----</span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>=<span class="number">3</span></span><br><span class="line">---innere----</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">---inners----</span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>=<span class="number">6</span></span><br><span class="line">---innere----</span><br></pre></td></tr></table></figure></li><li><p><strong>装饰器返回值</strong><br>装饰器还可以用来装饰带有返回值的函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---inners----&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---innere----&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">              </span><br><span class="line"><span class="meta">@w1           </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">---inners----</span><br><span class="line">---innere----</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上装饰器中带有返回值是可以装饰任何函数的，因为函数如果没有返回值，Python解释器会默认返回None的，装饰器中接收到函数的返回值为None，同样也返回None，就相当于没有返回值。</p></blockquote></li><li><p><strong>带参装饰器</strong><br>装饰器中也可以带参数，有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_arg</span>(<span class="params">pre = <span class="string">&quot;hello&quot;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">function</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func_in</span>():</span><br><span class="line">            <span class="built_in">print</span>(pre)</span><br><span class="line">            <span class="keyword">return</span> function()</span><br><span class="line">        <span class="keyword">return</span> func_in</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@func_arg(<span class="params"><span class="string">&quot;hehe&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---test1---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@func_arg(<span class="params"><span class="string">&quot;haha&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---test2---&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1()</span><br><span class="line">hehe</span><br><span class="line">---test1---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2()</span><br><span class="line">haha</span><br><span class="line">---test2---</span><br></pre></td></tr></table></figure><p>由此我们可以看出使用带参数的装饰器可以用同一种装饰器利用参数的不同从而达到不同的装饰效果。</p></li><li><p><strong>类装饰器</strong><br>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。<br>在Python中一般callable对象都是函数，但也有例外。<br>只要某个对象重写了<code>__call__()</code>方法，那么这个对象就是callable的。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure><p>类装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---初始化---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func name is %s&quot;</span>%func.__name__)</span><br><span class="line">        self.__func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---装饰器中的功能---&quot;</span>)</span><br><span class="line">        self.__func()</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明：</span></span><br><span class="line"><span class="comment">#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象</span></span><br><span class="line"><span class="comment">#    并且会把test这个函数名当做参数传递到__init__方法中</span></span><br><span class="line"><span class="comment">#    即在__init__方法中的func变量指向了test函数体</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#2. test函数相当于指向了用Test创建出来的实例对象</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用</span></span><br><span class="line"><span class="comment">#    所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----test---&quot;</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---初始化---</span><br><span class="line">func name is test</span><br><span class="line">---装饰器中的功能---</span><br><span class="line">----test---</span><br></pre></td></tr></table></figure></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在之前学习变量的作用域时，经常会提到局部变量和全局变量，之所有称之为局部、全局，就是因为他们的自作用的区域不同，这就是作用域。<br>用locals函数和globals函数可以分别打印当前作用域的局部变量和全局变量，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">globals</span>()</span><br><span class="line">&#123;<span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__loader__&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;, <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">locals</span>()</span><br><span class="line">&#123;<span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__loader__&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;, <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>由于当前作用域就是全局，因此打印出的局部和全局变量都是一样的。</p><ul><li><p><strong>LEGB规则</strong><br>Python使用LEGB的顺序来查找一个符号对应的对象：<br><strong>locals -&gt; enclosing function -&gt; globals -&gt; builtins</strong><br>首先从局部(locals)查找;<br>然后从外部嵌套的命名空间(enclosing function，常见于闭包中)中查找;<br>之后从全局(globals)中查找;<br>最后再到内建模块命名空间(builtins)中找。</p><p>Python在启动的时候会自动为我们载入很多内建的函数、类，比如 dict，list，type，print<br>这些都位于<code>__builtin__</code>模块中，可以使用<code>dir(__builtin__)</code>来查看。<br>这也是为什么我们在没有import任何模块的情况下，就能使用这么多丰富的函数和功能了。<br>使用<code>dir(__builtin__)</code>（注意：只能在ipython中查看）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="built_in">dir</span>(__builtin__)                                                                                                           </span><br><span class="line">Out[<span class="number">1</span>]: </span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;AssertionError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;AttributeError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;BaseException&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;BlockingIOError&#x27;</span>,</span><br><span class="line"> ...</span><br><span class="line"> <span class="string">&#x27;zip&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="Python-的动态性"><a href="#Python-的动态性" class="headerlink" title="Python 的动态性"></a>Python 的动态性</h3><p><strong>动态编程语言</strong>是<strong>高级程序设计语言</strong>的一个类别，在计算机科学领域已被广泛应用。<br>它是一类<strong>在运行时可以改变其结构的语言</strong>：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。<br>Python自然也是一种动态语言，在Python解释器运行的过程中可以动态地给对象绑定（添加）属性，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, age = <span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1 = Person(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;24&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1.sex</span><br><span class="line"><span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>在这里我们没有在类中定义sex这个属性，但是我们在运行的时候可以给对象动态地绑定一个sex属性，照样能打印出结果来。<br>但是如果换一个对象就还是没有sex的属性，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>P2 = Person(<span class="string">&quot;小丽&quot;</span>, <span class="string">&quot;25&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P2.sex</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#21&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    P2.sex</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;sex&#x27;</span></span><br></pre></td></tr></table></figure><p>那么我们如果想让这个类创建的所有对象都有sex属性怎么办？答案就是我们可以直接给类绑定属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.sex = <span class="literal">None</span> <span class="comment">#给类Person添加一个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1 = Person(<span class="string">&quot;小丽&quot;</span>, <span class="string">&quot;25&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(P1.sex)  <span class="comment">#如果P1这个实例对象中没有sex属性的话，那么就会访问它的类属性</span></span><br><span class="line"><span class="literal">None</span>  <span class="comment">#可以看到没有出现异常</span></span><br></pre></td></tr></table></figure><p>既然我们可以绑定属性，那么肯定也能绑定方法，绑定方法<strong>需要导入types模块</strong>，需要用到其中的<strong>MethodType方法</strong><br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line">   ...:     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>): </span><br><span class="line">   ...:         self.name = name </span><br><span class="line">   ...:         self.age = age </span><br><span class="line">   ...:     <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>): </span><br><span class="line">   ...:         <span class="built_in">print</span>(<span class="string">&quot;Eat food&quot;</span>) </span><br><span class="line">   ...:  </span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, speed</span>): </span><br><span class="line">   ...:     <span class="built_in">print</span>(<span class="string">&quot;%s在移动，速度为%d km/h&quot;</span> %(self.name, speed))</span><br><span class="line">In [<span class="number">4</span>]: P = Person(<span class="string">&quot;XiaoMing&quot;</span>, <span class="number">20</span>)</span><br><span class="line">In [<span class="number">5</span>]: P.eat()</span><br><span class="line">Eat food</span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">In [<span class="number">7</span>]: P.run = MethodType(run,P)</span><br><span class="line">In [<span class="number">8</span>]: P.run(<span class="number">140</span>)</span><br><span class="line">XiaoMing在移动，速度为<span class="number">140</span> km/h</span><br></pre></td></tr></table></figure><p>所以给类绑定一个方法格式为<code>类名.方法名 = MethodType(另外创建的函数,类)</code></p><p>如果想对一个类绑定类方法和动态方法，则不需要用MethodType函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: @<span class="built_in">classmethod</span> </span><br><span class="line">    ...: <span class="keyword">def</span> <span class="title function_">testClass</span>(<span class="params">cls</span>): </span><br><span class="line">    ...:     cls.num = <span class="number">100</span></span><br><span class="line">In [<span class="number">10</span>]: @<span class="built_in">staticmethod</span> </span><br><span class="line">    ...: <span class="keyword">def</span> <span class="title function_">testStatic</span>(): </span><br><span class="line">    ...:     <span class="built_in">print</span>(<span class="string">&quot;--- static method ---&quot;</span>)</span><br><span class="line">In [<span class="number">11</span>]: Person.testClass = testClass</span><br><span class="line">In [<span class="number">12</span>]: Person.testStatic = testStatic</span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">print</span>(Person.num)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">18</span>-56ef842e1620&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">print</span>(Person.num)</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="built_in">type</span> <span class="built_in">object</span> <span class="string">&#x27;Person&#x27;</span> has no attribute <span class="string">&#x27;num&#x27;</span></span><br><span class="line">In [<span class="number">14</span>]: Person.testClass()</span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">print</span>(Person.num)</span><br><span class="line"><span class="number">100</span></span><br><span class="line">In [<span class="number">17</span>]: Person.testStatic()</span><br><span class="line">--- static method ---</span><br></pre></td></tr></table></figure><p>如果想要删除属性或方法的话，用del关键字和delattr函数都可以<br>使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del 对象.属性名</span><br><span class="line">delattr(对象,&quot;属性名&quot;)</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>__slots__</code></strong><br>现在我们终于明白了，动态语言与静态语言的不同:<br><strong>动态语言</strong>：可以在运行的过程中，修改代码<br><strong>静态语言</strong>：编译时已经确定好代码，运行过程中不能修改<br>如果我们想要限制实例的属性怎么办？<br>比如，只允许对Person实例添加name和age属性。</p><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.name = <span class="string">&quot;老王&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.age = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.score = <span class="number">100</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#3&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;score&#x27;</span></span><br></pre></td></tr></table></figure><p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.score = <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>在Python中，<strong>类同样也是一种对象</strong>。<br>是的，没错，就是对象。<br>只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ObjectCreator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure><p>既然类的本质是对象，于是我们可以对类进行如下操作：<br>1、将它赋值给一个变量<br>2、可以拷贝它<br>3、可以为它增加属性<br>4、可以将它作为函数参数进行传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(ObjectCreator)  <span class="comment"># 你可以打印一个类，因为它其实也是一个对象</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">o</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> o</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator)  <span class="comment"># 你可以将类做为参数传给函数</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line">Fasle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class="string">&#x27;foo&#x27;</span>  <span class="comment"># 你可以为类增加属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(ObjectCreator.new_attribute))</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator  <span class="comment"># 你可以将类赋值给一个变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure><p>在Python中有个内建函数type，这个函数能让我们知道一个对象的类型是什么。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyCls</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">1</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(MyCls()))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.MyCls&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(MyCls)) </span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>结果发现我们对类的类型进行查看的时候居然的<strong>type</strong><br>type函数还有一种完全不同的功能，那就是它可以动态地创建类。<br>type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）<br>type可以这样工作：<br><code>type(类名，由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</code><br>如用type创建类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test = <span class="built_in">type</span>(<span class="string">&quot;Test&quot;</span>, () ,&#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test()</span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x7f64a074af90</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>type中第一个参数为类名，为字符串；<br>第二个参数为父类名，为继承所用，父类名不需要传入字符串；<br>第三个参数传入的是类属性，而不是实例属性。</p><p>我们还可以用type创建带有方法的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">echo_num</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(self.num)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@<span class="built_in">staticmethod</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">testStatic</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;static method...&quot;</span>) </span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">testClass</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(cls.num)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test = <span class="built_in">type</span>(<span class="string">&quot;Test&quot;</span>, (), &#123;<span class="string">&quot;num&quot;</span>:<span class="number">100</span>, <span class="string">&quot;echo_num&quot;</span>:echo_num, <span class="string">&quot;testStatic&quot;</span>:testStatic, <span class="string">&quot;testClass&quot;</span>:testClass&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.num</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.echo_num()</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.testStatic()</span><br><span class="line">static method...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.testClass()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>可以看到，用type指定函数不需要太多花里胡哨的东西，无论是什么函数都可以用于创建类。</p><p>说了这么多，那么到底什么是元类呢？<br><strong>元类就是用来创建类的“东西”</strong>。<br>你创建类就是为了创建类的实例对象，不是吗？<br>但是我们已经学习到了Python中的类也是对象。<br>元类就是用来创建这些类（对象）的，元类就是类的类。<br>我们所了解的type就可以创建一个类。<br>这是因为函数type实际上是一个元类。<br>type就是Python在背后用来创建所有类的元类。<br>现在你想知道那为什么type会全部采用小写形式而不是Type呢？<br>好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。<br>type就是创建类对象的类。你可以通过检查<code>__class__</code>属性来看到这一点。<br>Python中所有的东西，注意，我是指所有的东西——都是对象。<br>这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>():<span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Cls</span>(<span class="title class_ inherited__">object</span>):<span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Cls().__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Cls&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>从上面可以了解到，每个对象都可以查看<code>__class__</code>属性来查看这个对象的类型，也就是这个类是由什么类创建而来的<br>那么我们同样也能通过<code>__class__</code>来查看这个类是由什么类创建的，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Cls().__class__.__class__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>由此我们可以看出，无论是int还是str或者function等，都是由type创建出来的类。<br>因此，元类就是创建类这种对象的东西。<br>type就是Python的内建元类，当然了，你也可以创建自己的元类。</p><ul><li><p><strong><code>__metaclass__</code>属性</strong><br>你可以在定义一个类的时候为其添加<code>__metaclass__</code>属性。格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = something</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>如果你这么做了，Python就会用元类来创建类Foo。<br>你首先写下class Foo(object)，但是类Foo还没有在内存中创建。<br>Python会在类的定义中寻找<code>__metaclass__</code>属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。<br>当你写如下代码时 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Python做了如下的操作：<br>1、Foo中有<code>__metaclass__</code>这个属性吗？如果是，Python会通过<code>__metaclass__</code>创建一个名字为Foo的类(对象)<br>2、如果Python没有找到<code>__metaclass__</code>，它会继续在Bar（父类）中寻找<code>__metaclass__</code>属性，并尝试做和前面同样的操作。<br>3、如果Python在任何父类中都找不到<code>__metaclass__</code>，它就会在模块层次中去寻找<code>__metaclass__</code>，并尝试做同样的操作。<br>4、如果还是找不到<code>__metaclass__</code>,Python就会用内置的type来创建这个类对象。<br>现在的问题就是，你可以在<code>__metaclass__</code>中放置些什么代码呢？答案就是：可以创建一个类的东西。<br>那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。</p></li><li><p><strong>自定义元类</strong><br>元类的主要目的就是为了当创建类时能够自动地改变类。<br>通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。</p><p>假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。<br>有好几种方法可以办到，但其中一种就是通过在模块级别设定<code>__metaclass__</code>。<br>采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。<br>幸运的是，<code>__metaclass__</code>实际上可以被任意调用，它并不需要是一个正式的类。<br>所以，我们这里就先以一个简单的函数作为例子开始。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">    newAttr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name,value <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">            newAttr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用type来创建一个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, newAttr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="built_in">object</span>, metaclass=upper_attr):</span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">bip</span><br></pre></td></tr></table></figure><p>现在我们用一个真正的class来做一个元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UpperAttrMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line">    <span class="comment"># __new__是用来创建对象并返回之的方法</span></span><br><span class="line">    <span class="comment"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line">    <span class="comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class="line">    <span class="comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line">    <span class="comment"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line">    <span class="comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class="line">        <span class="comment">#遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">        newAttr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name,value <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">                newAttr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法1：通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class="line">        <span class="comment"># return type(future_class_name, future_class_parents, newAttr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法2：复用type.__new__方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="comment"># return type.__new__(cls, future_class_name, future_class_parents, newAttr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法3：使用super方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(UpperAttrMetaClass, cls).__new__(cls, future_class_name, future_class_parents, newAttr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#python2的用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        __metaclass__ = UpperAttrMetaClass</span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3的用法</span></span><br><span class="line"><span class="comment"># class Foo(object, metaclass = UpperAttrMetaClass):</span></span><br><span class="line"><span class="comment">#     bar = &#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出:True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br><span class="line"><span class="comment"># 输出:&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure><p>执行结果和上面的例子相同。<br>就是这样，除此之外，关于元类真的没有别的可说的了。<br>但就元类本身而言，它们其实是很简单的：<br>1、拦截类的创建<br>2、修改类<br>3、返回修改之后的类<br>究竟为什么要使用元类？<br>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：<br>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters</p></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li><p><strong>小整数对象池</strong><br>整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。<br>Python对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。<br>在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。<br>同理，单个字母也是这样的。但是当定义2个相同的字符串时，引用计数为0，触发垃圾回收。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = -<span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = -<span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = -<span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = -<span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>但是不在这个范围内的整数，Python是不会固定内存的，每一次都会创建一个新的对象，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>intern机制</strong><br>一个字符串中如果没有空格（也就是说这个字符串是一个”单词”），那么在Python中会采用intern机制。<br>重复创建相同的字符串是不会创建新的对象的，而是直接把之前的字符串的引用返回出来。<br>这就是所谓的intern机制。如果字符串中有空格的话，那么就不会开启intern机制。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)  </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a) == <span class="built_in">id</span>(b)   </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>引用计数机制</strong><br>Python中的垃圾回收机制是以引用计数为主的。<br>python里每一个东西都是对象，它们的核心就是一个结构体：PyObject：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="type">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。<br>当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op)   ((op)-&gt;ob_refcnt++) <span class="comment">//增加计数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op) \ <span class="comment">//减少计数</span></span></span><br><span class="line">    <span class="keyword">if</span> (--(op)-&gt;ob_refcnt != <span class="number">0</span>) \</span><br><span class="line">        ; \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        __Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure><p>当引用计数为0的时候，该对象生命就结束了。<br>引用计数机制的优点：<br>1、简单<br>2、实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。<br>引用计数机制的缺点：<br>1、维护引用计数消耗资源<br>2、循环引用</p><p>循环引用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure><p>list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。<br>对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集)</p><p>导致引用计数+1的情况：<br>1、对象被创建，例如a&#x3D;23<br>2、对象被引用，例如b&#x3D;a<br>3、对象被作为参数，传入到一个函数中，例如func(a)<br>4、对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>导致引用计数-1的情况：<br>1、对象的别名被显式销毁，例如del a<br>2、对象的别名被赋予新的对象，例如a&#x3D;24<br>3、一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）<br>4、对象所在的容器被销毁，或从容器中删除对象</p><p>查看一个对象的引用计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a) </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样可以查看a对象的引用计数，但是会比正常计数大1，因为调用<code>sys.getrefcount</code>函数的时候将a传入，这会让a的引用计数+1</p></li><li><p><strong>gc模块</strong><br>gc模块提供一个接口给开发者设置垃圾回收的选项。<br>上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p><p>常用函数：<br>1、<code>gc.set_debug(flags)</code> 设置gc的debug日志，一般设置为gc.DEBUG_LEAK<br>2、<code>gc.collect([generation])</code> 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。返回不可达（unreachable objects）对象的数目<br>3、<code>gc.get_threshold()</code> 获取的gc模块中自动执行垃圾回收的频率。<br>4、<code>gc.set_threshold(threshold0[, threshold1[, threshold2])</code> 设置自动执行垃圾回收的频率。<br>5、<code>gc.get_count()</code> 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</p><p>如果要使用gc模块的自动拉垃圾回收机制，必须要<code>import gc</code>模块，并且<code>is_enable()=True</code>才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。<br><strong>垃圾回收&#x3D;垃圾检查+垃圾回收</strong></p><p>在Python中，采用分代收集的方法。<br>把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。<br>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。<br>例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(gc.get_count())</span><br><span class="line">(<span class="number">76</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = ClassA()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(gc.get_count())</span><br><span class="line">(<span class="number">77</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(gc.get_count())</span><br><span class="line">(<span class="number">76</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="内建属性"><a href="#内建属性" class="headerlink" title="内建属性"></a>内建属性</h3><p>Python3中的内建属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在Python3中定义一个类的时候如果不写父类的话会默认继承object类，而在Python2中不会这样，在Python2中无继承父类（称之为经典类）。<br>子类没有实现<code>__init__</code>方法时，默认自动调用父类的。<br>如定义<code>__init__</code>方法时，需自己手动调用父类的<code>__init__</code>方法</p><p>常用的专有属性表如下：</p><table><thead><tr><th align="center">常用专有属性</th><th align="center">说明</th><th>触发方式</th></tr></thead><tbody><tr><td align="center"><code>__init__</code></td><td align="center">构造初始化函数</td><td>创建实例后，赋值时使用，在<code>__new__</code>之后</td></tr><tr><td align="center"><code>__new__</code></td><td align="center">生成实例所需属性</td><td>创建实例时</td></tr><tr><td align="center"><code>__class__</code></td><td align="center">实例所在类</td><td><code>实例.__class__</code></td></tr><tr><td align="center"><code>__str__</code></td><td align="center">实例字符串表示，可读性</td><td>print(类实例)，如果没有实现，会使用repr结果</td></tr><tr><td align="center"><code>__repr__</code></td><td align="center">实例字符串表示，准确性</td><td>类实例回车（交互式），或使用print(repr(类实例))</td></tr><tr><td align="center"><code>__del__</code></td><td align="center">析构方法</td><td>del删除实例或实例被回收</td></tr><tr><td align="center"><code>__dict__</code></td><td align="center">实例自定义属性</td><td><code>vars.(实例.__dict__)</code></td></tr><tr><td align="center"><code>__doc__</code></td><td align="center">类文档，子类不继承</td><td>help(类或实例)</td></tr><tr><td align="center"><code>__getattribute__</code></td><td align="center">属性访问拦截器</td><td>访问实例属性时</td></tr><tr><td align="center"><code>__bases__</code></td><td align="center">类的所有父类构成元素</td><td><code>类名.__bases__</code></td></tr></tbody></table><p>重点说一下<code>__getattribute__</code>，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a = <span class="string">&quot;a&quot;</span> </span><br><span class="line">        self.b = <span class="string">&quot;b&quot;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问属性时进行拦截</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;log a&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self,obj)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a</span><br><span class="line">log a</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.b</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>注意：<code>__getattribute__</code>是有坑的，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self,obj</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---test---&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> obj.startswith(<span class="string">&quot;a&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hahha&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            <span class="keyword">return</span> self.test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;heihei&quot;</span>)</span><br><span class="line"></span><br><span class="line">t = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t.a)  <span class="comment">#返回hahha</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t.b)  <span class="comment">#会让程序死掉</span></span><br></pre></td></tr></table></figure><p>程序执行后，首先打印了一个test然后跟着打印了haha，之后就一直打印test直到程序死掉，报错：<br><code>RecursionError: maximum recursion depth exceeded while calling a Python object</code>（递归错误）</p><p>原因：当t.b执行时，会调用Person类中定义的__getattribute__方法，但是在这个方法的执行过程中if条件不满足。<br>所以，程序执行else里面的代码，即return self.test。<br>问题就在这，因为return 需要把self.test的值返回，那么首先要获取self.test的值，因为self此时就是t这个对象，所以self.test就是t.test。<br>此时要获取t这个对象的test属性，那么就会跳转到__getattribute__方法去执行，即此时产生了递归调用，由于这个递归过程中没有判断什么时候退出，所以这个程序会永无休止的运行下去，又因为每次调用函数，就需要保存一些数据，那么随着调用的次数越来越多，最终内存吃光，所以程序崩溃<br><strong>注意：以后不要在__getattribute__方法中调用self.xxxx</strong></p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>启动python解释器，输入dir(<strong>builtins</strong>), 可以看到很多python解释器启动后默认加载的属性和函数，这些函数称之为<strong>内建函数</strong><br>这些函数因为在编程时使用较多，cpython解释器用c语言实现了这些函数，启动解释器时默认加载。<br>这些函数数量众多，不宜记忆，开发时不是都用到的，待用到时再help(function), 查看如何使用，或结合网络查询即可，在这里介绍些常用的内建函数。</p><ul><li><p><strong>range</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(stop) -&gt; <span class="built_in">list</span> of integers</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step]) -&gt; <span class="built_in">list</span> of integers</span><br></pre></td></tr></table></figure><p><strong>start</strong>:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;<br><strong>stop</strong>:到stop结束，但不包括stop.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5<br><strong>step</strong>:每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)<br>python2中range返回列表，python3中range返回一个迭代值。如果想得到列表,可通过list函数。<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Dec  <span class="number">4</span> <span class="number">2017</span>, <span class="number">14</span>:<span class="number">50</span>:<span class="number">18</span>) </span><br><span class="line">[GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux2</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (default, Nov <span class="number">23</span> <span class="number">2017</span>, <span class="number">16</span>:<span class="number">37</span>:01) </span><br><span class="line">[GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>map</strong><br>map函数会根据提供的函数对指定序列做映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, sequence[, sequence, ...]) -&gt; <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><strong>function</strong>:是一个函数<br><strong>sequence</strong>:是一个或多个序列,取决于function需要几个参数<br>参数序列中的每一个元素分别调用function函数，返回包含每次function函数返回值的list。<br><strong>注意：在Python2中map返回的是一个列表，而在Python3中返回的是一个迭代器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Dec  <span class="number">4</span> <span class="number">2017</span>, <span class="number">14</span>:<span class="number">50</span>:<span class="number">18</span>) </span><br><span class="line">[GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux2</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (default, Nov <span class="number">23</span> <span class="number">2017</span>, <span class="number">16</span>:<span class="number">37</span>:01) </span><br><span class="line">[GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>以Python2为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x,y:x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (x,y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(func, a, b)</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;e&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>简单来说，map就是利用函数来生成列表&#x2F;迭代器</p></li><li><p><strong>filter</strong><br>filter函数会对指定序列执行过滤操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function <span class="keyword">or</span> <span class="literal">None</span>, sequence) -&gt; <span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="keyword">or</span> string</span><br></pre></td></tr></table></figure><p><strong>function</strong>:接受一个参数，返回布尔值True或False<br><strong>sequence</strong>:序列可以是str，tuple，list<br>filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。<br>python2中返回值的类型和参数sequence的类型相同，Python3返回迭代器：<br>Python3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>Python2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>reduce</strong><br>reduce函数，reduce函数会对参数序列中元素进行累积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reduce(...)</span><br><span class="line">    reduce(function, sequence[, initial]) -&gt; value</span><br><span class="line"></span><br><span class="line">    Apply a function of two arguments cumulatively to the items of a sequence,<span class="keyword">from</span> left to right, so <span class="keyword">as</span> to reduce the sequence to a single value.For example, reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) calculates    ((((<span class="number">1</span>+<span class="number">2</span>)+<span class="number">3</span>)+<span class="number">4</span>)+<span class="number">5</span>).  If initial <span class="keyword">is</span> present, it <span class="keyword">is</span> placed before the items of the sequence <span class="keyword">in</span> the calculation, <span class="keyword">and</span> serves <span class="keyword">as</span> a default when the sequence <span class="keyword">is</span> empty.</span><br></pre></td></tr></table></figure><p><strong>function</strong>:该函数有两个参数<br><strong>sequence</strong>:序列可以是str，tuple，list<br><strong>initial</strong>:固定初始值<br>reduce依次从sequence中取一个元素，和上一次调用function的结果做参数再次调用function。<br>第一次调用function时，如果提供initial参数，会以sequence中的第一个元素和initial作为参数调用function，否则会以序列sequence中的前两个元素做参数调用function。<br>注意function函数不能为None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="number">5</span>) </span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y, [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;eabcd&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在Python3里,reduce函数已经被从全局名字空间里移除了, 它现在被放置在fucntools模块里用的话要先引入：<code>from functools import reduce</code></p></li><li><p><strong>sorted</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>) --&gt; new <span class="built_in">sorted</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>这个函数可以对一个列表进行排序<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>],reverse=<span class="number">1</span>) </span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])          </span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],reverse=<span class="number">1</span>)</span><br><span class="line">[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><p>functools 是python2.5被引人的,一些工具函数放在此包里。<br>想使用functools中的函数，需要导入functools模块<br>在Python2中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(functools)</span><br><span class="line">[<span class="string">&#x27;WRAPPER_ASSIGNMENTS&#x27;</span>, <span class="string">&#x27;WRAPPER_UPDATES&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;cmp_to_key&#x27;</span>, <span class="string">&#x27;partial&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>, <span class="string">&#x27;total_ordering&#x27;</span>, <span class="string">&#x27;update_wrapper&#x27;</span>, <span class="string">&#x27;wraps&#x27;</span>]</span><br></pre></td></tr></table></figure><p>Python3中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(functools)    </span><br><span class="line">[<span class="string">&#x27;MappingProxyType&#x27;</span>, <span class="string">&#x27;RLock&#x27;</span>, <span class="string">&#x27;WRAPPER_ASSIGNMENTS&#x27;</span>, <span class="string">&#x27;WRAPPER_UPDATES&#x27;</span>, <span class="string">&#x27;WeakKeyDictionary&#x27;</span>, <span class="string">&#x27;_CacheInfo&#x27;</span>, <span class="string">&#x27;_HashedSeq&#x27;</span>, <span class="string">&#x27;__all__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;_c3_merge&#x27;</span>, <span class="string">&#x27;_c3_mro&#x27;</span>, <span class="string">&#x27;_compose_mro&#x27;</span>, <span class="string">&#x27;_convert&#x27;</span>, <span class="string">&#x27;_find_impl&#x27;</span>, <span class="string">&#x27;_ge_from_gt&#x27;</span>, <span class="string">&#x27;_ge_from_le&#x27;</span>, <span class="string">&#x27;_ge_from_lt&#x27;</span>, <span class="string">&#x27;_gt_from_ge&#x27;</span>, <span class="string">&#x27;_gt_from_le&#x27;</span>, <span class="string">&#x27;_gt_from_lt&#x27;</span>, <span class="string">&#x27;_le_from_ge&#x27;</span>, <span class="string">&#x27;_le_from_gt&#x27;</span>, <span class="string">&#x27;_le_from_lt&#x27;</span>, <span class="string">&#x27;_lru_cache_wrapper&#x27;</span>, <span class="string">&#x27;_lt_from_ge&#x27;</span>, <span class="string">&#x27;_lt_from_gt&#x27;</span>, <span class="string">&#x27;_lt_from_le&#x27;</span>, <span class="string">&#x27;_make_key&#x27;</span>, <span class="string">&#x27;cmp_to_key&#x27;</span>, <span class="string">&#x27;get_cache_token&#x27;</span>, <span class="string">&#x27;lru_cache&#x27;</span>, <span class="string">&#x27;namedtuple&#x27;</span>, <span class="string">&#x27;partial&#x27;</span>, <span class="string">&#x27;partialmethod&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>, <span class="string">&#x27;singledispatch&#x27;</span>, <span class="string">&#x27;total_ordering&#x27;</span>, <span class="string">&#x27;update_wrapper&#x27;</span>, <span class="string">&#x27;wraps&#x27;</span>]</span><br></pre></td></tr></table></figure><p>python3中增加了更多工具函数，做业务开发时大多情况下用不到，此处介绍使用频率较高的2个函数。</p><ul><li><p><strong>partial</strong><br>把一个函数的某些参数设置默认值，返回一个新的函数，调用这个新函数会更简单。<br>如有一函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kw)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1 = partial(test, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1()</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2 = partial(test, a=<span class="number">3</span>, b=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2()</span><br><span class="line">()</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;linux&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;linux&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">()</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>wraps</strong><br>使用装饰器时，有一些细节需要被注意。<br>例如，被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）。<br>添加后由于函数名和函数的doc发生了改变，对测试结果有一些影响，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">note</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;note function&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="string">&quot;inner function&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;note something&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@note</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="string">&quot;test function&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(test.__doc__)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">note something</span><br><span class="line">I am test</span><br><span class="line">inner function</span><br></pre></td></tr></table></figure><p>可见，使用装饰器之后改变了函数的doc信息文档。<br>所以，Python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">note</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;note function&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="string">&quot;inner function&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;note something&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@note</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="string">&quot;test function&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(test.__doc__)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">note something</span><br><span class="line">I am test</span><br><span class="line">test function</span><br></pre></td></tr></table></figure><p>函数doc文档又回到以前的文档了</p></li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>pdb是基于命令行的调试工具，非常类似gnu的gdb（调试c&#x2F;c++）。</p><table><thead><tr><th align="center">命令</th><th align="center">简写命令</th><th>作用</th></tr></thead><tbody><tr><td align="center">continue</td><td align="center">c</td><td>继续执行程序</td></tr><tr><td align="center">list</td><td align="center">l</td><td>查看代码</td></tr><tr><td align="center">step</td><td align="center">s</td><td>进入函数</td></tr><tr><td align="center">return</td><td align="center">r</td><td>执行到函数返回处</td></tr><tr><td align="center">quit</td><td align="center">q</td><td>终止并退出</td></tr><tr><td align="center">next</td><td align="center">n</td><td>逐行执行</td></tr><tr><td align="center">print</td><td align="center">p</td><td>显示变量值</td></tr><tr><td align="center">help</td><td align="center">h</td><td>帮助</td></tr><tr><td align="center">args</td><td align="center">a</td><td>查看传入参数</td></tr><tr><td align="center">break</td><td align="center">b</td><td>显示所有断点</td></tr><tr><td align="center">break #</td><td align="center">b #</td><td>在第#行设置断点</td></tr><tr><td align="center">break FILE:#</td><td align="center">b FILE:#</td><td>在FILE文件的第#行设置断点</td></tr><tr><td align="center">clear #</td><td align="center">cl #</td><td>删除#号断点</td></tr><tr><td align="center"></td><td align="center">回车</td><td>重复上条命令</td></tr></tbody></table><p>调试方法有多种，第一种是用Python命令的时候加参数进行pdb调试：<br><code>python -m pdb SOME.py</code><br>第二种是在交互式界面中进行调试（不推荐）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.run(<span class="string">&#x27;testfun(args)&#x27;</span>) <span class="comment">#此时会打开pdb调试，注意：先使用s跳转到这个testfun函数中，然后就可以使用l看到代码了</span></span><br></pre></td></tr></table></figure><p>第三种是在程序中设置断点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> pdb </span><br><span class="line">pdb.set_trace() </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>pdb 调试有个明显的缺陷就是对于多线程，远程调试等支持得不够好，同时没有较为直观的界面显示，不太适合大型的 python 项目。<br>而在较大的python项目中，这些调试需求比较常见，因此需要使用更为高级的调试工具。</p><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>可以在百度等搜索引擎上搜索pep8中文就可以看见pep8文档的中文版本<br><a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0008/">pep8 官网规范地址:</a><br>Guido的关键点之一是：代码更多是用来读而不是写。编码规范旨在改善Python代码的可读性。<br>风格指南强调一致性。项目、模块或函数保持一致都很重要。</p><ul><li><p><strong>参数缩进</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对准左括号</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不对准左括号，但加多一层缩进，以和后面内容区别。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_function_name</span>(<span class="params"></span></span><br><span class="line"><span class="params">        var_one, var_two, var_three,</span></span><br><span class="line"><span class="params">        var_four</span>):</span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 悬挂缩进必须加多一层缩进.</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br></pre></td></tr></table></figure></li><li><p><strong>条件缩进</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有额外缩进，不是很好看，个人不推荐.</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加注释</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    <span class="comment"># Since both conditions are true, we can frobnicate.</span></span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外添加缩进,推荐。</span></span><br><span class="line"><span class="comment"># Add some extra indentation on the conditional continuation line.</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">        <span class="keyword">and</span> that_is_another_thing):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></li><li><p><strong>列表缩进</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 右括号不回退，个人不推荐</span></span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    ]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右括号回退</span></span><br><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的。<br>这种概念在计算机中称之为<strong>多任务</strong>。<br>什么叫“多任务”呢？</p><blockquote><p>简单地说，就是操作系统可以同时运行多个任务。<br>打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。<br>还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p></blockquote><p>编写完毕的代码，在没有运行的时候，称之为<strong>程序</strong><br>正在运行着的代码，就成为<strong>进程</strong><br>进程，除了包含代码以外，还有需要运行的环境等，所以和程序是有区别的</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ret = os.fork()</span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello 1&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello 2&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello 2</span><br><span class="line">Hello 1</span><br></pre></td></tr></table></figure><p>那么我明明写了个条件语句，为什么会执行2次呢？</p><blockquote><p>当程序执行到os.fork()处时，操作系统会创建一个新的进程（子进程）<br>然后复制父进程的所有信息到子进程中同时执行<br>之后父子进程都会有返回值，父进程返回的是子进程的进程号(pid)，子进程得到的返回值将会是0<br>之后再同时执行之后的代码。</p></blockquote><p><strong>注意</strong>：这里父进程创建了子进程之后是不管子进程了的，父进程结束之后子进程如果没有结束就变成孤儿进程。<br>在Linux中执行Python程序的时候，只要父进程（也可以称之为主进程）一结束，就当做一个程序执行完毕，这时候会弹出命令提示符。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> fork</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">ret = fork()</span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Child-Begin---&quot;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Child-End---&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Father-Begin---&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Father-End---&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 test.py</span><br><span class="line">---Father-Begin---</span><br><span class="line">---Child-Begin---</span><br><span class="line">---Father-End---</span><br><span class="line">root@LINUX pythonSource# ---Child-End---</span><br></pre></td></tr></table></figure><p>可以看到，当父进程结束后，系统是把整个程序当做执行完毕来处理的，这时候子进程还有没有执行完毕，命令提示符出来之后子进程才执行完毕。</p><h3 id="getpid-和-getppid"><a href="#getpid-和-getppid" class="headerlink" title="getpid 和 getppid"></a>getpid 和 getppid</h3><p>每个进程都有自己的进程号，也就是<strong>pid</strong>；<br>同时每个进程也有父进程号，为<strong>ppid</strong>，父进程号也就是创建自己的那个进程的pid。<br>os模块中可以通过getpid和getppid函数来获取当前进程的pid和ppid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> fork,getpid,getppid</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">ret = fork()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret = %d&quot;</span> %ret)</span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Child, pid:%s, ppid:%s---&quot;</span> %(getpid(), getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Father, pid:%s, ppid:%s---&quot;</span> %(getpid(), getppid()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---%s Done---&quot;</span> %getpid())</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret = 4913</span><br><span class="line">---Father, pid:4912, ppid:3826---</span><br><span class="line">---4912 Done---</span><br><span class="line">ret = 0</span><br><span class="line">---Child, pid:4913, ppid:4912---</span><br><span class="line">---4913 Done---</span><br></pre></td></tr></table></figure><h3 id="多进程中的全局变量"><a href="#多进程中的全局变量" class="headerlink" title="多进程中的全局变量"></a>多进程中的全局变量</h3><p>在多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响。<br>简单来说，全局变量只对当前进程有效，在其他进程中不能共享。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> fork</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">100</span> </span><br><span class="line">ret = fork()</span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---process-1---&quot;</span>)</span><br><span class="line">    g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---process-1 g_num=%d---&quot;</span>%g_num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---process-2---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---process-2 g_num=%d---&quot;</span>%g_num)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---process-1---</span><br><span class="line">---process-1 g_num=101---</span><br><span class="line">---process-2---</span><br><span class="line">---process-2 g_num=100---</span><br></pre></td></tr></table></figure><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>fork是Unix&#x2F;Linux上面的底层函数，在Windows上不能执行fork函数，难道在Windows上无法用Python编写多进程的程序吗？<br>Python作为一个跨品台的语言，自然也应该提供一个跨平台的多进程支持。<br><strong>multiprocessing</strong>模块就是跨平台版本的多进程模块。<br>multiprocessing模块中提供了一个Process类来代表一个进程对象，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br><span class="line">    target：表示这个进程实例所调用对象；</span><br><span class="line">    args：表示调用对象的位置参数元组；</span><br><span class="line">    kwargs：表示调用对象的关键字参数字典；</span><br><span class="line">    name：为当前进程实例的别名；</span><br><span class="line">    group：大多数情况下用不到；</span><br></pre></td></tr></table></figure><p>用Process创建进程之后<code>对象名.start()</code>即可开启进程<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep     </span><br><span class="line">                  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():       </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---%d---&quot;</span>%i)</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">p = Process(target=test)</span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---main---&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---main---</span><br><span class="line">---0---</span><br><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br></pre></td></tr></table></figure><p>可见主进程在创建子进程之后会继续执行，执行到最后一步的时候会等子进程执行完毕后主进程才会执行完毕。</p><p>Process类常用方法：<br><code>is_alive()</code>：判断进程实例是否还在执行；<br><code>join([timeout])</code>：是否等待进程实例执行结束，或等待多少秒；<br><code>start()</code>：启动进程实例（创建子进程）；<br><code>run()</code>：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；<br>terminate()：不管任务是否完成，立即终止；<br>Process类常用属性：<br><strong>name</strong>：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；<br><strong>pid</strong>：当前进程实例的PID值；</p><h3 id="自定义-Process-子类"><a href="#自定义-Process-子类" class="headerlink" title="自定义 Process 子类"></a>自定义 Process 子类</h3><p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类<br>每次实例化这个类的时候，就等同于实例化一个进程对象<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep     </span><br><span class="line">                  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;---%d---&quot;</span>%i)</span><br><span class="line">            sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">p = MyProcess()</span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---main-%d---&quot;</span>%i)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python3 test.py</span><br><span class="line">---main-0---</span><br><span class="line">---0---</span><br><span class="line">---main-1---</span><br><span class="line">---1---</span><br><span class="line">---main-2---</span><br><span class="line">---2---</span><br><span class="line">---main-3---</span><br><span class="line">---3---</span><br><span class="line">---main-4---</span><br><span class="line">---4---</span><br></pre></td></tr></table></figure><p>在自定义的Process类中，其实只需要重写run方法就行了，因为用start方法开启进程的时候会自动调用类中的run方法<br>因此我们在自定义Process类中的时候在run方法中写一些骚操作就完成了我们的自定义Process类<br>下面的一个比较全面的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid,getppid</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承Process类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Process_Class</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="comment"># 因为Process类本身也有__init__方法，这个子类相当于重写了这个方法，</span></span><br><span class="line">    <span class="comment"># 但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性，</span></span><br><span class="line">    <span class="comment"># 最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作</span></span><br><span class="line">    <span class="comment"># 然后再定义我们的想要的属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val</span>):</span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.val = val </span><br><span class="line"></span><br><span class="line">    <span class="comment">#重写了Process类的run()方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子进程(%s) 开始执行，父进程为（%s）&quot;</span>%(getpid(),getppid()))</span><br><span class="line">        t_start = time()</span><br><span class="line">        sleep(self.val)</span><br><span class="line">        t_stop = time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s)执行结束，耗时%0.2f秒&quot;</span>%(getpid(),t_stop-t_start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t_start = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前程序进程(%s)&quot;</span>%getpid())    </span><br><span class="line">    p1 = Process_Class(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#对一个不包含target属性的Process类执行start()方法，就会运行这个类中的run()方法，所以这里会执行p1.run()</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s)执行结束，耗时%0.2f&quot;</span>%(getpid(),t_stop-t_start))</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前程序进程(6106)</span><br><span class="line">子进程(6107) 开始执行，父进程为（6106）</span><br><span class="line">(6107)执行结束，耗时2.00秒</span><br><span class="line">(6106)执行结束，耗时2.01</span><br></pre></td></tr></table></figure><h3 id="Pool-进程池"><a href="#Pool-进程池" class="headerlink" title="Pool 进程池"></a>Pool 进程池</h3><blockquote><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。<br>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行。</p></blockquote><p>multiprocessing.Pool常用函数解析：<br><code>apply_async(func[, args[, kwds]])</code>：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；<br><code>apply(func[, args[, kwds]])</code>：使用阻塞方式调用func（通常不使用，使用阻塞方式就变成单任务模式了）<br><code>close()</code>：关闭Pool，使其不再接受新的任务；<br><code>terminate()</code>：不管任务是否完成，立即终止；<br><code>join()</code>：主进程阻塞，和Process的join类似。等待子进程的退出， 必须在close或terminate之后使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---pid=%d, num=%d---&quot;</span>%(getpid(), num))</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---%d---&quot;</span>%i)</span><br><span class="line">    pool.apply_async(worker,(i,))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">---0---</span><br><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---5---</span><br><span class="line">---6---</span><br><span class="line">---pid=6476, num=0---</span><br><span class="line">---pid=6478, num=1---</span><br><span class="line">---pid=6477, num=2---</span><br><span class="line">---pid=6478, num=1---</span><br><span class="line">---pid=6477, num=2---</span><br><span class="line">---pid=6476, num=0---</span><br><span class="line">---pid=6478, num=1---</span><br><span class="line">---pid=6477, num=2---</span><br><span class="line">---pid=6476, num=0---</span><br><span class="line">---pid=6478, num=3---</span><br><span class="line">---pid=6476, num=4---</span><br><span class="line">---pid=6477, num=5---</span><br><span class="line">---pid=6478, num=3---</span><br><span class="line">---pid=6477, num=5---</span><br><span class="line">---pid=6476, num=4---</span><br><span class="line">---pid=6477, num=5---</span><br><span class="line">---pid=6476, num=4---</span><br><span class="line">---pid=6478, num=3---</span><br><span class="line">---pid=6478, num=6---</span><br><span class="line">---pid=6478, num=6---</span><br><span class="line">---pid=6478, num=6---</span><br></pre></td></tr></table></figure><blockquote><p>用进程池创建进程时，如果如果不用join方法来阻塞主进程的话，主进程执行完毕是不会等待子进程的，子进程将被直接销毁。这一点和Process有很大的区别。<br>使用apply&#x2F;apply_async方法向进程池中添加任务的时候，如果添加的任务数量超过了进程池中的进程数，那么会导致这些添加的进程等待。直到进程池中有进程完成之后才进去。<br>调用close就会关闭进程池，此时不能再添加新的任务。</p></blockquote><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。<br>这里主要介绍<strong>Queue</strong>来实现进程间通信。<br>Queue本身是一个消息列队程序，初始化Queue()对象时（例如：q&#x3D;Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）</p><ul><li><code>Queue.qsize()</code>：返回当前队列包含的消息数量；</li><li><code>Queue.empty()</code>：如果队列为空，返回True，反之False；</li><li><code>Queue.full()</code>：如果队列满了，返回True,反之False；</li><li><code>Queue.get([block[, timeout]])</code>：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</li><li><code>Queue.get_nowait()</code>：相当Queue.get(False)；</li><li><code>Queue.put(item,[block[, timeout]])</code>：将item消息写入队列，block默认值为True；</li><li><code>Queue.put_nowait(item)</code>：相当于Queue.put(item, False)；</li></ul><blockquote><p>关于get方法，如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；<br>而关于put方法：如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常。</p></blockquote><p>Queue实例：<br>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="string">&quot;ABCDEFG&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Put %s to queue&quot;</span>%i)</span><br><span class="line">        q.put(i)</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Get %s from queue&quot;</span>%value)</span><br><span class="line">            sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给子进程</span></span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pw.join()</span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Put A to queue</span><br><span class="line">Put B to queue</span><br><span class="line">Put C to queue</span><br><span class="line">Put D to queue</span><br><span class="line">Put E to queue</span><br><span class="line">Put F to queue</span><br><span class="line">Put G to queue</span><br><span class="line">Get A from queue</span><br><span class="line">Get B from queue</span><br><span class="line">Get C from queue</span><br><span class="line">Get D from queue</span><br><span class="line">Get E from queue</span><br><span class="line">Get F from queue</span><br><span class="line">Get G from queue</span><br></pre></td></tr></table></figure><p>进程池中的Queue<br>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()<br>下面的实例演示了进程池中的进程如何通信：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Pool</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid,getppid</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">q</span>):       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reader start, pid:%s, ppid:%s&quot;</span>%(getpid(), getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;reader从Queue获取消息：%s&quot;</span>%q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;writer start, pid:%s, ppid:%s&quot;</span>%(getpid(), getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;ABCDE&quot;</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s Start&quot;</span>%getpid())</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply(writer, (q,))</span><br><span class="line">    po.apply(reader, (q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s End&quot;</span>%getpid())</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">16575 Start</span><br><span class="line">writer start, pid:16583, ppid:16575</span><br><span class="line">reader start, pid:16584, ppid:16575</span><br><span class="line">reader从Queue获取消息：A</span><br><span class="line">reader从Queue获取消息：B</span><br><span class="line">reader从Queue获取消息：C</span><br><span class="line">reader从Queue获取消息：D</span><br><span class="line">reader从Queue获取消息：E</span><br><span class="line">16575 End</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>我们前面所说的同步就是各线程按顺序执行，那么什么是异步呢？<br>简单来说：<br>同步调用就是你喊你朋友吃饭，你朋友在忙 ，你就一直在那等，等你朋友忙完了，你们一起去<br>异步调用就是你喊你朋友吃饭，你朋友说知道了，待会忙完去找你，你就去做别的了。<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid,getppid</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---进程池中的进程---pid=%d,ppid=%d--&quot;</span>%(getpid(),getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----%d---&quot;</span>%i)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hahah&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---callback func--pid=%d&quot;</span>%getpid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---callback func--args=%s&quot;</span>%args)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line">pool.apply_async(func=test,callback=test2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----主进程-pid=%d----&quot;</span>%getpid())</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---进程池中的进程---pid=3446,ppid=3445--</span><br><span class="line">----0---</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">----1---</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">----2---</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">---callback func--pid=3445</span><br><span class="line">---callback func--args=hahah</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">----主进程-pid=3445----</span><br><span class="line">----主进程-pid=3445----</span><br></pre></td></tr></table></figure><p>这里的异步是靠apply_async中的callback参数来实现的，将其中的callback参数设定为某个任务<br>等这个进程执行完之后会通知主进程执行callback设定的任务，此时主进程会放下自己的工作</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>此案例为用多进程复制某个目录中的所有文本文件（不包括目录和其他文件）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Manager</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyFileTask</span>(<span class="params">fileName,oldDirName,newDirName,queue</span>):</span><br><span class="line">    <span class="string">&quot;完成copy一个文件的功能&quot;</span></span><br><span class="line">    fr = <span class="built_in">open</span>(oldDirName+<span class="string">&#x27;/&#x27;</span>+fileName)</span><br><span class="line">    fw = <span class="built_in">open</span>(newDirName+<span class="string">&#x27;/&#x27;</span>+fileName, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">    content = fr.read()</span><br><span class="line">    fw.write(content)</span><br><span class="line"></span><br><span class="line">    fw.close()</span><br><span class="line">    fr.close()</span><br><span class="line"></span><br><span class="line">    queue.put(fileName)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 获取要copy的目录名字</span></span><br><span class="line">    oldDirName = <span class="built_in">input</span>(<span class="string">&quot;请输入目录名: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建目录</span></span><br><span class="line">    newDirName = oldDirName+<span class="string">&quot;-1&quot;</span></span><br><span class="line">    os.mkdir(newDirName)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 获取old目录中所有文件的名字</span></span><br><span class="line">    fileNames = os.listdir(oldDirName)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 使用多进程方式copy原目录中所有文件到新的目录中</span></span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> tempFile <span class="keyword">in</span> fileNames:</span><br><span class="line">        pool.apply_async(copyFileTask, args=(tempFile,oldDirName,newDirName,queue,))</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    allNum = <span class="built_in">len</span>(fileNames)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        queue.get()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        copyRate = num/allNum</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\rcopy进度为：%.2f%%&quot;</span>%(copyRate*<span class="number">100</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> num == allNum:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n已完成copy...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程，能够完成多任务，比如在一台电脑上能够同时运行多个QQ<br>线程，也能够完成多任务，比如一个QQ中的多个聊天窗口<br><strong>进程是系统进行资源分配和调度的一个独立单位</strong><br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位<br>线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程和线程的区别：</p><blockquote><p>1、一个程序至少有一个进程,一个进程至少有一个线程<br>2、 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高<br>3、进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>4、线程不能够独立执行，必须依存在进程中</p></blockquote><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>python的thread模块是比较底层的模块<br>python的threading模块是对thread做了一些包装的，可以更加方便的被使用。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=test)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行时等待了1秒后直接打印5遍“Hello World”<br>可以明显看出使用了多线程并发的操作，花费时间要短很多<br>注意：创建好的线程，需要调用start()方法来启动<br>创建了线程之后其实是有个主线程的，主线程会等待所有的子线程执行完毕后结束<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=test)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End...&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Start...</span><br><span class="line">End...</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>这时主线程是一路执行到底但是不会退出（因为没有显示命令提示符）<br>等到所有的子线程执行结束之后才弹出命令提示符，代表着主线程执行结束</p><h3 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h3><p>通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发<br>为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承<strong>threading.Thread</strong>就可以了，然后重写<strong>run</strong>方法。<br>python的<strong>threading.Thread</strong>类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法<br>而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;---%s:%d---&quot;</span>%(self.name, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End...&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Start...</span><br><span class="line">End...</span><br><span class="line">---Thread-2:0---</span><br><span class="line">---Thread-1:0---</span><br><span class="line">---Thread-3:0---</span><br><span class="line">---Thread-3:1---</span><br><span class="line">---Thread-1:1---</span><br><span class="line">---Thread-2:1---</span><br><span class="line">---Thread-2:2---</span><br><span class="line">---Thread-1:2---</span><br><span class="line">---Thread-3:2---</span><br></pre></td></tr></table></figure><p>和Process类似，线程对象自带的名字是Thread-#，创建第一个就是-1，第二个为-2，以此类推。<br>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。<br>当执行到sleep语句时，线程将被阻塞(Blocked)，到sleep结束后，线程进入就绪(Runnable)状态，等待调度。<br>而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p><h3 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h3><p>在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享(这点要比多进程要好)。<br>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱(即线程非安全)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">100</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work1, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work2, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start, the num is %d&quot;</span>%g_num)</span><br><span class="line">t1 = Thread(target=work1)</span><br><span class="line">t1.start()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">t2 = Thread(target=work2)</span><br><span class="line">t2.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End, the num is %d&quot;</span>%g_num)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start, the num is 100</span><br><span class="line">In work1, the num is 103</span><br><span class="line">In work2, the num is 103</span><br><span class="line">End, the num is 103</span><br></pre></td></tr></table></figure><p>如果在多线程中频繁地对某个全局变量进行操作的时候，有可能某个线程还没操作完就被其他线程操作了，这时候那个没操作完的也会当成操作完毕了。<br>这时候也许不会发生我们期望的结果，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work1, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work2, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line">t1 = Thread(target=work1)</span><br><span class="line">t1.start()</span><br><span class="line">t2 = Thread(target=work2)</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In work1, the num is 1217118</span><br><span class="line">In work2, the num is 1368661</span><br></pre></td></tr></table></figure><p>可以看到，我每个线程都对g_num这个全局变量加了1000000次，而得到的结果却不是2000000。<br>这就是所谓的线程不安全。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。<br>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p><blockquote><p>互斥锁为资源引入一个状态：锁定&#x2F;非锁定<br>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改<br>直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源<br>互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p></blockquote><p>threading模块中定义了Lock类，可以方便的处理锁定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment">#锁定</span></span><br><span class="line">mutex.acquire([blocking])</span><br><span class="line"><span class="comment">#释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>其中，锁定方法acquire可以有一个blocking参数:<br>如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True）<br>如果设定blocking为False，则当前线程不会堵塞</p><p>现在我们就可以利用这个互斥锁来解决上面的1000000次加法出现的bug：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        mutex.acquire()  <span class="comment">#上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment">#解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work1, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        mutex.acquire()  <span class="comment">#上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment">#解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;In work2, the num is %d&quot;</span>%g_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一把互斥锁，默认情况下是没有上锁的</span></span><br><span class="line">mutex = Lock()</span><br><span class="line">t1 = Thread(target=work1)</span><br><span class="line">t1.start()</span><br><span class="line">t2 = Thread(target=work2)</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In work1, the num is 1960577</span><br><span class="line">In work2, the num is 2000000</span><br></pre></td></tr></table></figure><h3 id="线程不共享局部变量"><a href="#线程不共享局部变量" class="headerlink" title="线程不共享局部变量"></a>线程不共享局部变量</h3><p>在多线程开发中，全局变量是多个线程都共享的数据，而局部变量等是各自线程的，是非共享的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,current_thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    name = current_thread().name</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- thread name is %s ---&quot;</span>%name)</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- thread name is %s, num = %d ---&quot;</span>%(name, num))</span><br><span class="line"></span><br><span class="line">t1 = Thread(target=test)</span><br><span class="line">t2 = Thread(target=test)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- thread name is Thread-1 ---</span><br><span class="line">--- thread name is Thread-1, num = 101 ---</span><br><span class="line">--- thread name is Thread-2 ---</span><br><span class="line">--- thread name is Thread-2, num = 100 ---</span><br></pre></td></tr></table></figure><p>由此可见，局部变量在各个线程之间是互不影响的。<br>因为各个线程在执行的过程中都是当做执行各自的函数，因此局部变量是不会收到其他线程的影响的。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。<br>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步就是<strong>协同步调，按预定的先后次序进行运行</strong>。<br>如:你说完，我再说。<br>“同”字从字面上容易理解为一起动作。其实不是，”同”字应是指协同、协助、互相配合。<br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B依言执行，再将结果给A;A再继续操作。<br>简单来说，<strong>同步就是按顺序执行</strong>。<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task1</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock1.acquire():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;------Task 1 -----&quot;</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock2.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task2</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock2.acquire():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;------Task 2 -----&quot;</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock3.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task3</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock3.acquire():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;------Task 3 -----&quot;</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock1.release()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Lock创建出的锁默认没有“锁上”</span></span><br><span class="line">lock1 = Lock()</span><br><span class="line"><span class="comment">#创建另外一把锁，并且“锁上”</span></span><br><span class="line">lock2 = Lock()</span><br><span class="line">lock2.acquire()</span><br><span class="line"><span class="comment">#创建另外一把锁，并且“锁上”</span></span><br><span class="line">lock3 = Lock()</span><br><span class="line">lock3.acquire()</span><br><span class="line"></span><br><span class="line">t1 = Task1()</span><br><span class="line">t2 = Task2()</span><br><span class="line">t3 = Task3()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------Task 1 -----</span><br><span class="line">------Task 2 -----</span><br><span class="line">------Task 3 -----</span><br><span class="line">------Task 1 -----</span><br><span class="line">------Task 2 -----</span><br><span class="line">------Task 3 -----</span><br><span class="line">------Task 1 -----</span><br><span class="line">------Task 2 -----</span><br><span class="line">------Task 3 -----</span><br><span class="line">------Task 1 -----</span><br><span class="line">------Task 2 -----</span><br><span class="line">------Task 3 -----</span><br></pre></td></tr></table></figure><p>这就是一个利用互斥锁来达到线程同步的一个效果。</p><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。<br>在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。<br>同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。<br>为了解决这个问题于是引入了<strong>生产者和消费者模式</strong>。<br>生产者消费者模式是<strong>通过一个容器来解决生产者和消费者的强耦合问题</strong>。<br>生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。<br>这个阻塞队列就是用来给生产者和消费者解耦的。<br>下面是一个生产者和消费者的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># python2中</span></span><br><span class="line"><span class="comment">#from Queue import Queue</span></span><br><span class="line"><span class="comment"># python3中</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">                    count = count +<span class="number">1</span></span><br><span class="line">                    msg = <span class="string">&#x27;生成产品&#x27;</span>+<span class="built_in">str</span>(count)</span><br><span class="line">                    queue.put(msg)</span><br><span class="line">                    <span class="built_in">print</span>(msg)</span><br><span class="line">                sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &gt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    msg = self.name + <span class="string">&#x27;消费了 &#x27;</span>+queue.get()</span><br><span class="line">                    <span class="built_in">print</span>(msg)</span><br><span class="line">                sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">        queue.put(<span class="string">&quot;初始产品&quot;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建2个生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建5个消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure><p>执行结果不予演示<br>Queue的说明<br>1、对于Queue，在多线程通信之间扮演重要的角色<br>2、添加数据到队列中，使用put()方法<br>3、从队列中取数据，使用get()方法<br>4、判断队列中是否还有数据，使用qsize()方法<br>简单来说，生产者和消费者模式就是创建了一个缓冲区来解决线程两端一边处理数据块而另一边处理数据慢的问题。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>在多线程环境下，每个线程都有自己的数据。<br>一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p><ul><li><p><strong>使用函数传参的方法</strong><br>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>(<span class="params">name</span>):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    <span class="comment"># std是局部变量，但是每个函数都要用它，因此必须传进去：</span></span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br></pre></td></tr></table></figure><p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的Student对象，不能共享。</p></li><li><p><strong>使用全局字典的方法</strong><br>如果用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">std_thread</span>(<span class="params">name</span>):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    <span class="comment"># 把std放到全局变量global_dict中：</span></span><br><span class="line">    global_dict[threading.current_thread()] = std</span><br><span class="line">    do_task_1()</span><br><span class="line">    do_task_2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>():</span><br><span class="line">    <span class="comment"># 不传入std，而是根据当前线程查找：</span></span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>():</span><br><span class="line">    <span class="comment"># 任何函数都可以查找出当前线程的std变量：</span></span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这种方式理论上是可行的，它最大的优点是消除了std对象在每层函数中的传递问题，但是，每个函数获取std的代码有点low。<br>那么有没有更简单的方式呢？</p></li><li><p><strong>使用ThreadLocal</strong><br>ThreadLocal是一个类，可以在全局定义它的对象。<br>这样一来，它虽然是全局变量，但是每个线程对它的读写都是互不影响的。<br>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,local,current_thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></span><br><span class="line">local_school = local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>():</span><br><span class="line">    <span class="comment"># 获取当前线程关联的student:</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s (in %s)&#x27;</span> % (std, current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_thread</span>(<span class="params">stu</span>):</span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></span><br><span class="line">    local_school.student = stu</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = Thread(target= process_thread, args=(<span class="string">&#x27;XiaoMing&#x27;</span>,), name=<span class="string">&#x27;Thread-A&#x27;</span>)</span><br><span class="line">t2 = Thread(target= process_thread, args=(<span class="string">&#x27;XiaoWang&#x27;</span>,), name=<span class="string">&#x27;Thread-B&#x27;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, XiaoMing (in Thread-A)</span><br><span class="line">Hello, XiaoWang (in Thread-B)</span><br></pre></td></tr></table></figure><p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。<br>你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。<br>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。<br>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。<br><strong>总结</strong>：<br>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<br>所以，ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题</p></li></ul><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>GIL就是<strong>全局解释器锁</strong>。<br>如果要在Python中使用多线程的时候，实际上Python中的做法是模拟多线程，但实际上还是单线程。<br>原理就是用GIL锁来让各线程轮流执行(如果是CPU多核心的话，可以用死循环来查看多线程占用CPU的情况，会发现各CPU是不会满资源工作的)，而使用多进程就是满资源工作。<br>我们可以解决这个问题，那就是<strong>让Python执行C代码</strong>。<br>首先用gcc SOURCE.c -shared -o libXXXXX.so将C源代码编译成动态库文件，然后在Python中加载动态库执行就行了。<br>Python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载动态库（这个动态库就是用C源代码编译而来的）</span></span><br><span class="line">lib = cdll.LoadLibrary(<span class="string">&quot;./libdeadloop.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个子线程，让其执行C语言编写的函数</span></span><br><span class="line">t = Thread(target=lib.DeadLoop)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程也调用那个函数</span></span><br><span class="line">lib.DeadLoop()</span><br></pre></td></tr></table></figure><p>运行之后可以看到CPU满资源工作</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，又称<strong>微线程</strong>。<br>首先我们得知道协程是啥？协程其实可以认为是<strong>比线程更小的执行单元</strong>。<br>为啥说他是一个执行单元，因为他自带CPU上下文。<br>这样只要在合适的时机，我们可以把一个协程切换到另一个协程。<br>只要这个过程中保存或恢复CPU上下文那么程序还是可以运行的。<br>那么这个过程看起来比线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复CPU上下文这么简单。<br>操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。<br>所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。<br>在<strong>IO密集型</strong>的程序中由于IO操作远远慢于CPU的操作，所以往往需要CPU去等IO操作。<br>同步IO下系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。<br>这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。<br>所以人们发明了异步IO。就是当数据到达的时候触发我的回调，来减少线程切换带来性能损失。<br>但是这样的坏处也是很大的，主要的坏处就是操作被 “分片” 了，代码写的不是 “一气呵成” 这种。而是每次来段数据就要判断数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。<br>这样代码的可读性很低，其实也不符合人类的习惯。但是协程可以很好解决这个问题。<br>比如把一个IO操作写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。<br>要知道协程的切换很轻的。协程通过这种对异步IO的封装既保留了性能也保证了代码的容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。</p><p>生成器是可以当做协程来使用的，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---A---&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---B---&quot;</span>)</span><br><span class="line">        <span class="built_in">next</span>(c)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = A() </span><br><span class="line">    B(a)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---B---</span><br><span class="line">---A---</span><br><span class="line">---B---</span><br><span class="line">---A---</span><br><span class="line">---B---</span><br><span class="line">---A---</span><br><span class="line">---B---</span><br><span class="line">---A---</span><br><span class="line">---B---</span><br><span class="line">---A---</span><br><span class="line">---B---</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其实用生成器做出来的协程理解起来是比较困难的，代码可读性也比较差。因此我们有另外的模块可以实现协程。</p><ul><li><p><strong>greenlet</strong><br>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单<br>案例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;---A--&quot;</span></span><br><span class="line">        gr2.switch()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;---B--&quot;</span></span><br><span class="line">        gr1.switch()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到gr1中运行</span></span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure><p>使用greenlet做出来的协程方便理解</p></li><li><p><strong>gevent</strong><br>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要着急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent。<br>其原理是当一个greenlet遇到IO(指的是input output输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。<br>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br>下面就是一个gevent实现的TCP服务器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> socket,monkey</span><br><span class="line"><span class="comment"># 该语句会修改Python中的一些方法</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recv:&quot;</span>, data)</span><br><span class="line">        conn.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">port</span>):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.bind((<span class="string">&#x27;&#x27;</span>, port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cli, addr = s.accept()</span><br><span class="line">        gevent.spawn(handle_request, cli)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server(<span class="number">7788</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络就是一种辅助双方或者多方能够连接在一起的工具<br>所谓的网络编程就是，让在不同的电脑上的软件能够进行数据传递，即<strong>进程之间的通信</strong></p><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做<strong>TCP&#x2F;IP协议</strong><br>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，<strong>互联网协议簇(Internet Protocol Suite)<strong>就是通用协议标准。<br>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称</strong>TCP&#x2F;IP协议</strong>。<br><strong>注意</strong>：TCP&#x2F;IP协议是一个协议族，里面包含了很多协议<br>常用的网络协议如下图所示：</p><blockquote><p>TCP&#x2F;IP协议将网络分为4个层次：<strong>链路层、网络层、传输层、应用层</strong><br>而ISO标准则将网络分为7个层次：<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong><br>其中的物理层和数据链路层对应4层模型中的链路层，网络层和传输层分别对应4层模型中的网络层和传输层，而会话层、表示层和应用层则对应4层模型中的应用层</p></blockquote><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>那么TCP&#x2F;IP协议中的端口指的是什么呢？端口就好一个房子的门，是出入这间房子的必经之路。<br>如果一个进程需要收发网络数据，那么就需要有这样的端口。<br>在linux系统中，端口可以有65536（2的16次方）个之多！既然有这么多，操作系统为了统一管理，所以进行了编号，这就是端口号。<br>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535。<br><strong>注意</strong>：端口号不是随意使用的，而是按照一定的规定进行分配。</p><p><strong>端口有什么用呢？</strong></p><blockquote><p>我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP、FTP、SMTP等，这些服务完全可以通过1个IP地址来实现。<br>那么，主机是怎样区分不同的网络服务呢？<br>显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。<br>实际上是通过<strong>IP地址+端口号</strong>来区分不同的服务的。<br>需要注意的是，端口并不是一一对应的。<br>比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用”3457”这样的端口。</p></blockquote><p><strong>注意</strong>：一个端口号只能对应一个进程，如果某个进程的端口号被占用，那么那个进程只能用其他的端口号或者不能打开这个进程。</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP地址：<strong>用来在网络中标记一台电脑的一串数字</strong>，如192.168.1.1<br>IP地址在本地局域网上是<strong>惟一</strong>的。<br>每一个IP地址包括两部分：网络地址和主机地址。<br>IP地址分为五类，这几类IP地址不加赘述，只介绍一下私有IP：<br>在这么多网络IP中，国际规定有一部分IP地址是用于我们的局域网使用，也就是属于私网IP，不在公网中使用的，它们的范围是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0～10.255.255.255</span><br><span class="line">172.16.0.0～172.31.255.255</span><br><span class="line">192.168.0.0～192.168.255.255</span><br></pre></td></tr></table></figure><p>注意：IP地址127．0．0．1~127．255．255．255用于回路测试。<br>如：127.0.0.1可以代表本机IP地址，用<code>http://127.0.0.1</code>就可以测试本机中配置的Web服务器。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>要想理解什么是子网掩码，就不能不了解IP地址的构成。</p><blockquote><p>互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。<br>IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，以便于IP地址的寻址操作。<br>IP地址的网络号和主机号各是多少位呢？<br>如果不指定，就不知道哪些位是网络号、哪些是主机号，这就需要通过子网掩码来实现。<br>子网掩码不能单独存在，它必须结合IP地址一起使用。<br>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分子网掩码的设定必须遵循一定的规则。</p></blockquote><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><strong>socket</strong>(套接字)是用于网络间进行通信的一种方式。<br>它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket来完成通信的。<br>在Python中使用socket模块中的socket类即可完成套接字对象的创建：<br><code>socket.socket(AddressFamily, Type)</code><br>函数socket.socket创建一个socket，返回该socket的<strong>描述符</strong>，该函数带有两个参数：</p><ul><li><strong>Address Family</strong><br>可以选择<code>AF_INET</code>(用于Internet进程间通信)或者<code>AF_UNIX</code>(用于同一台机器进程间通信),实际工作中常用AF_INET</li><li><strong>Type</strong><br>套接字类型，可以是<code>SOCK_STREAM</code>(流式套接字，主要用于TCP协议)或者<code>SOCK_DGRAM</code>(数据报套接字，主要用于UDP协议)。</li></ul><p>socket在Python中实际上是一个类，用socket创建的也就是一个对象。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>UDP</strong>(用户数据报协议)，是一个<strong>无连接</strong>的简单的<strong>面向数据报</strong>的运输层协议。<br>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。<br>由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。<br>UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><p><strong>UDP特点</strong>：<br>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。<br>UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p><p><strong>UDP程序流程如下</strong>：<br>1、创建套接字；<br>2、接收&#x2F;发送数据(如果是服务器还要绑定端口)<br>3、关闭套接字</p><ul><li><p><strong>发送数据</strong><br>socket类中有个方法为sendto，用于发送数据，使用格式如下(这是Python3中的，Python2中sendto的第一个参数是str类型的)：<br><code>sendto(data[, flags], address) -&gt; count</code><br>其中data为<strong>byte类型</strong>的参数，如果需要把字符串转为byte类型的数据的话，在字符串前面加个’b’就行了<br>也可以调用str类中的<strong>encode</strong>方法对字符串进行编码也能转化为byte类型的数据<br>下面是一个UDP套接字发送信息的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">udpSocket.sendto(<span class="string">b&quot;haha&quot;</span>, (<span class="string">&quot;10.106.48.72&quot;</span>, <span class="number">4000</span>))</span><br></pre></td></tr></table></figure><p>执行多次之后，用网络调试助手测试的结果如下：</p><p>可以发现，每次程序发送消息的时候都是用不同的端口来发送消息的。<br>原因是我们没有指定发送消息的端口号，这样一来，执行程序的时候操作系统会随机找一个没有被用过的端口号来执行我们的程序。那么如何指定我们要发送消息的端口号呢？</p></li><li><p><strong>绑定端口</strong><br>在socket类中有个bind方法，这个方法就是用来绑定IP地址和端口号的，用法如下：<br><code>bind(address)</code><br>其中的address是一个元组，元组内需要包含IP地址和端口号(IP号用str类型表示，可以为空，这样就代表绑定本机所有IP；端口号是int类型)</p><p>下面我们来绑定端口号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSocket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">udpSocket.sendto(<span class="string">b&quot;haha&quot;</span>, (<span class="string">&quot;10.106.48.72&quot;</span>, <span class="number">4000</span>))</span><br></pre></td></tr></table></figure><p>绑定端口号之后发送消息，网络调试助手的结果显示如下：</p><p>可以看到这回是同一个端口接收到的数据。</p></li><li><p><strong>接收数据</strong><br>socket能发送数据，同样也能接收数据。<br>在socket类中有个recv方法可以用于接收数据，用法如下：<br><code>recv(buffersize[, flags]) -&gt; data</code><br>其中的buffersize用于指定可接收的最大字节数；<br>返回值为byte类型的对象，也就是str前加上一个b，如果需要让byte类型的对象转化为str类型的对象，调用byte类型的<strong>decode</strong>方法解除编码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSocket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">recvData = udpSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;接收到的数据为：%s&quot;</span>%recvData.decode(<span class="string">&quot;gb2312&quot;</span>))</span><br></pre></td></tr></table></figure><p>用网络调试工具发送消息之后，接收结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收到的数据为：Hello Ubuntu</span><br></pre></td></tr></table></figure><p>除了recv方法，还有一个方法可以接收数据，那就<strong>recvfrom</strong>方法，这个方法不仅能接收数据，还能收到数据的来源，用法如下：<br><code>recvfrom(buffersize[, flags]) -&gt; (data, address info)</code><br>传递的参数和recv是一样的，但是返回值不一样，recvfrom方法的返回值是一个元组，第一个元素为接收到的byte类型的数据，第二个元素为IP地址和端口号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udpSocket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">recvData,recvFrom = udpSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;接收到%s的数据为：%s&quot;</span>%(recvFrom[<span class="number">0</span>], recvData.decode(<span class="string">&quot;gb2312&quot;</span>)))</span><br></pre></td></tr></table></figure><p>用调试助手发送数据的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接收到10.106.48.72的数据为：Hello Ubuntu</span><br></pre></td></tr></table></figure></li><li><p><strong>广播</strong><br>udp同样能进行广播的发送，如下，运行结果不予显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line">dest = (<span class="string">&#x27;&lt;broadcast&gt;&#x27;</span>, <span class="number">7788</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建udp套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 对这个需要发送广播数据的套接字进行修改设置，否则不能发送广播数据</span></span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以广播的形式发送数据到本网络的所有电脑中</span></span><br><span class="line">s.sendto(<span class="string">&quot;Hi&quot;</span>, dest)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;等待对方回复（按ctrl+c退出）&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    (buf, address) = s.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Received from %s: %s&quot;</span> % (address, buf)</span><br></pre></td></tr></table></figure></li><li><p><strong>UDP聊天室</strong><br>这个UDP网络聊天室是用2个线程（当然也可以用2个进程）完成的，可以在接收消息的同时发送消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收数据线程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recvData</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recvInfo = udpSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r&gt;&gt;%s:%s\n&lt;&lt;&quot;</span> %(<span class="built_in">str</span>(recvInfo[<span class="number">1</span>]), recvInfo[<span class="number">0</span>].decode(<span class="string">&quot;gb2312&quot;</span>)), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发数据线程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendData</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sendInfo = <span class="built_in">input</span>(<span class="string">&quot;&lt;&lt;&quot;</span>)</span><br><span class="line">        udpSocket.sendto(sendInfo.encode(<span class="string">&quot;gb2312&quot;</span>), (destIP, destPort))</span><br><span class="line"></span><br><span class="line">udpSocket = <span class="literal">None</span></span><br><span class="line">destIP = <span class="string">&quot;10.106.48.72&quot;</span></span><br><span class="line">destPort = <span class="number">8899</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> udpSocket</span><br><span class="line">    <span class="keyword">global</span> destIP</span><br><span class="line">    <span class="keyword">global</span> destPort</span><br><span class="line"></span><br><span class="line">    <span class="comment">#destIP = input(&quot;对方IP地址为: &quot;)</span></span><br><span class="line">    <span class="comment">#destPort = int(input(&quot;对方端口号为: &quot;))</span></span><br><span class="line"></span><br><span class="line">    udpSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">    udpSocket.bind((<span class="string">&quot;&quot;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line">    tr = Thread(target=recvData)</span><br><span class="line">    ts = Thread(target=sendData)</span><br><span class="line"></span><br><span class="line">    tr.start()</span><br><span class="line">    ts.start()</span><br><span class="line"></span><br><span class="line">    tr.join()</span><br><span class="line">    ts.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果不予显示</p></li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP为传输控制协议，和UDP不同的是：TCP需要先建立连接，然后才能发送数据。<br>TCP程序流程如下：</p><ul><li><p><strong>TCP三次握手</strong><br>TCP三次握手是在建立连接的时候使用的一种策略</p></li><li><p><strong>TCP四次挥手</strong><br>在TCP连接关闭的时候会有4次挥手</p></li><li><p><strong>TCP状态</strong><br>TCP一共有10种状态，如下图所示：</p></li><li><p><strong>MSL</strong><br>MSL就是数据包从客服端到达服务器或从服务器到达客户端的最长时间。<br>TCP连接关闭的时候最后发送关闭确认的一方需要等待2MSL的时间然后关闭连接。</p><blockquote><p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态<br>当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间<br>等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。<br>在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。<br>当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。<br>不过在实际应用中可以通过设置<strong>SO_REUSEADDR</strong>选项达到不必等待2MSL时间结束再使用此端口。</p></blockquote></li><li><p><strong>长连接和短连接</strong><br>TCP在真正的读写操作之前，<strong>server与client之间必须建立一个连接</strong><br>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立通过三次握手，释放则需要四次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。<br>模拟一种TCP短连接的情况:<br>1、client 向 server 发起连接请求<br>2、server 接到请求，双方建立连接<br>3、client 向 server 发送消息<br>4、server 回应 client<br>5、一次读写完成，此时双方任何一个都可以发起 close 操作<br>在步骤5中，一般都是client先发起close操作。当然也不排除有特殊的情况。<br>从上面的描述看，短连接一般只会在client&#x2F;server间传递一次读写操作！<br>再模拟一种长连接的情况:<br>1、client 向 server 发起连接<br>2、server 接到请求，双方建立连接<br>3、client 向 server 发送消息<br>4、server 回应 client<br>5、一次读写完成，连接不关闭<br>6、后续读写操作…<br>7、长时间操作之后client发起关闭请求</p><blockquote><p>由此可知长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。<br>对于频繁请求资源的客户来说，较适用长连接。<br>client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损<br>如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。<br>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。<br>但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p></blockquote></li><li><p><strong>listen</strong><br>socket类中有个方法为<strong>listen</strong>，这个方法用于监听tcp连接的。<br>只有执行这个方法的时候才能接收连接。<br>还有种说法是socket创建的套接字默认属性是主动的，使用listen方法可以将其变为被动的套接字，这样一来就可以接收别人的连接了。<br>listen使用方法如下：<br><code>listen([backlog])</code><br>其中的backlog表示设定的最大半连接和已连接数。如果连接数超过了这个值，那么客户端的connect将会被阻塞。<br><strong>注意</strong>：在Linux下这个值随便填多少都是一样的。</p></li><li><p><strong>accept</strong><br>socket类中有个方法为<strong>accept</strong>，该函数不需要参数，返回值是一个元组(socket object, address info)。<br>其中第一个元素为套接字，也就是说accept接收连接之后会创建一个新的套接字来使用这个连接；<br>第二个元素为接收连接的地址信息，也是个元组，包含了IP地址和端口号。<br><strong>注意</strong>：accept方法会造成阻塞。</p></li><li><p><strong>TCP服务器</strong><br>下面建立一个简单的TCP服务器：<br>流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、socket创建一个套接字</span><br><span class="line">2、bind绑定ip和port</span><br><span class="line">3、listen使套接字变为可以被动链接</span><br><span class="line">4、accept等待客户端的链接</span><br><span class="line">5、recv/send接收发送数据</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">tcpSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定端口号</span></span><br><span class="line">tcpSocket.bind((<span class="string">&quot;&quot;</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment"># 使用listen方法将套接字变为被动套接字</span></span><br><span class="line">tcpSocket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器</span></span><br><span class="line"><span class="comment"># newSocket用来为这个客户端服务</span></span><br><span class="line"><span class="comment"># tcpSocket就可以省下来专门等待其他新客户端的链接</span></span><br><span class="line">newSocket,clientInfo = tcpSocket.accept()</span><br><span class="line"></span><br><span class="line">recvData = newSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;接收到的数据：%s&quot;</span>%recvData.decode(<span class="string">&quot;gb2312&quot;</span>))</span><br><span class="line">newSocket.send(<span class="string">b&quot;Thank you!&quot;</span>)</span><br><span class="line"></span><br><span class="line">newSocket.close()</span><br><span class="line">tcpSocket.close()</span><br></pre></td></tr></table></figure><p>之后就可以用tcp客户端（如网络调试助手）来连接这个服务器了</p></li><li><p><strong>TCP客户端</strong><br>TCP客户端的搭建比服务器要简单许多，只需4步即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建套接字；</span><br><span class="line">2、连接服务器</span><br><span class="line">3、接收/发送数据</span><br><span class="line">4、关闭套接字</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 使用connect方法连接服务器</span></span><br><span class="line">clientSocket.connect((<span class="string">&quot;10.106.48.72&quot;</span>, <span class="number">8899</span>))</span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line">clientSocket.send(<span class="string">&quot;HeiHei&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 接收数据</span></span><br><span class="line">recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(recvData.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><p>然后就可以在服务器上看到对应的消息了。</p></li></ul><h3 id="TCP-单进程服务器"><a href="#TCP-单进程服务器" class="headerlink" title="TCP 单进程服务器"></a>TCP 单进程服务器</h3><p>单进程服务器是一种简单的单进程服务器，特点如下：<br>1、同一时刻只能为一个客户进行服务，不能同时为多个客户服务<br>2、当服务器为一个客户端服务时，而另外的客户端发起了connect，只要服务器listen的队列有空闲的位置，就会为这个新客户端进行连接，并且客户端可以发送数据，但当服务器为这个新客户端服务时，可能一次性把所有数据接收完毕<br>3、当recv接收数据时，返回值为空，即没有返回数据，那么意味着客户端已经调用了close关闭了；因此服务器通过判断recv接收数据是否为空来判断客户端是否已经下线<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复使用绑定的信息(也就是在服务器意外结束之后仍然可以绑定该信息)</span></span><br><span class="line">serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绑定本地信息</span></span><br><span class="line">address = (<span class="string">&quot;&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">serSocket.bind(address)</span><br><span class="line"><span class="comment"># 将主动套接字变为被动监听状态</span></span><br><span class="line">serSocket.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---等待新客户端到来---&quot;</span>)</span><br><span class="line">    newSocket,clientAddr = serSocket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- %s已连接 ---&quot;</span> %clientAddr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            recvData = newSocket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> recvData:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> %(<span class="built_in">str</span>(clientAddr), recvData.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;客户端关闭&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        newSocket.close()</span><br><span class="line"></span><br><span class="line">serSocket.close()</span><br></pre></td></tr></table></figure><p>执行结果自己尝试。</p><ul><li><strong>非阻塞单进程服务器</strong><br>我们都知道accept方法在调用的时候会产生<strong>阻塞</strong>，因此单进程服务器才不能接收多个客户端的请求。<br>所以我们只要accept方法不再阻塞，就可以使用单进程来接收多个客户端的请求了。<br>在socket类中有个方法为<strong>setblocking</strong>，将其中的参数改为False就可以让accept方法不再阻塞。<br><strong>注意</strong>：设置为非阻塞之后，如果accept的时候没有客户端的连接请求会出现异常，因此需要使用try来捕获这个异常。<br>代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 设置套接字重复绑定本地信息</span></span><br><span class="line">serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绑定本地信息</span></span><br><span class="line">address = (<span class="string">&quot;&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">serSocket.bind(address)</span><br><span class="line"><span class="comment"># 设置accept为非堵塞</span></span><br><span class="line">serSocket.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 将套接字改为被动监听</span></span><br><span class="line">serSocket.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">clientAddrList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        newSocket,newAddr = serSocket.accept()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s connected...&quot;</span>%<span class="built_in">str</span>(newAddr))</span><br><span class="line">        newSocket.setblocking(<span class="literal">False</span>)</span><br><span class="line">        clientAddrList.append((newSocket, newAddr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> clientSocket,clientAddr <span class="keyword">in</span> clientAddrList:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            recvData = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> recvData:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span>%(<span class="built_in">str</span>(clientAddr), recvData.decode(<span class="string">&quot;gb2312&quot;</span>)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                clientSocket.close()</span><br><span class="line">                clientAddrList.remove((clientSocket,clientAddr))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s closed...&quot;</span>%(<span class="built_in">str</span>(clientAddr)))</span><br><span class="line"></span><br><span class="line">setsockopt.close()</span><br></pre></td></tr></table></figure>这样一来，我们就可以使用单进程服务器来接收多个客户端的请求了。</li></ul><h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p>所谓的并发服务器就是能在同一时间为多个客户端进行服务。<br>可以用<strong>多进程或者多线程</strong>来实现并发。</p><ul><li><p><strong>多进程服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为客户端服务进程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clinetProcess</span>(<span class="params">newSocket, clinetAddr</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recvData = newSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> recvData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> %(<span class="built_in">str</span>(clinetAddr), recvData.decode(<span class="string">&quot;gb2312&quot;</span>)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s closed...&quot;</span>%<span class="built_in">str</span>(clinetAddr))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    newSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 重复使用绑定信息</span></span><br><span class="line">    serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 绑定本机信息</span></span><br><span class="line">    address = (<span class="string">&quot;&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">    serSocket.bind(address)</span><br><span class="line"></span><br><span class="line">    serSocket.listen(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            newSocket,clinetAddr = serSocket.accept()</span><br><span class="line">            <span class="comment"># 创建新的进程为新的客户端服务</span></span><br><span class="line">            newProcess = Process(target=clinetProcess,args=(newSocket,clinetAddr))</span><br><span class="line">            newProcess.start()</span><br><span class="line"></span><br><span class="line">            newSocket.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        serSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：多进程消耗的资源是比较大的，如果有较多的客户端的时候，使用多进程可能导致服务器崩溃。</p></li><li><p><strong>多线程服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clientThread</span>(<span class="params">newSocket, clientAddr</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recvData = newSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> recvData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> %(<span class="built_in">str</span>(clientAddr), recvData.decode(<span class="string">&quot;gb2312&quot;</span>)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;--- %s closed... ---&quot;</span> %<span class="built_in">str</span>(clientAddr))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    newSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    address = (<span class="string">&quot;&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">    serSocket.bind(address)</span><br><span class="line"></span><br><span class="line">    serSocket.listen(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            newSocket,clientAddr = serSocket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;--- %s connected... ---&quot;</span>%<span class="built_in">str</span>(clientAddr))</span><br><span class="line">            newThread = Thread(target=clientThread, args=(newSocket,clientAddr))</span><br><span class="line">            newThread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        newSocket.close()</span><br><span class="line">        serSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="select-服务器"><a href="#select-服务器" class="headerlink" title="select 服务器"></a>select 服务器</h3><p>在IO多路复用(单一进程完成多个任务)的模型中，比较常用的有select和epoll模型。<br>这两个都是系统接口，由操作系统提供。当然，Python的select模块进行了更高级的封装。</p><blockquote><p>网络通信被Unix系统抽象为文件的读写，通常是一个设备，由设备驱动程序提供，驱动可以知道自身的数据是否可用。<br>支持阻塞操作的设备驱动通常会实现一组自身的等待队列，如读&#x2F;写等待队列用于支持上层(用户层)所需的block或non-block操作。<br>设备的文件的资源如果可用（可读或者可写）则会通知进程，反之则会让进程睡眠，等到数据到来可用的时候，再唤醒进程。<br>这些设备的文件描述符被放在一个数组中，然后select调用的时候遍历这个数组，如果对于的文件描述符可读则会返回改文件描述符。<br>当遍历结束之后，如果仍然没有一个可用设备文件描述符，select让用户进程则会睡眠，直到等待资源可用的时候在唤醒，遍历之前那个监视的数组。每次遍历都是依次进行判断的。</p></blockquote><p>select模块中有个select函数，使用方法如下：<br><code>select(rlist, wlist, xlist[, timeout]) -&gt; (rlist, wlist, xlist)</code><br>传入的3个主要参数为<strong>收数据套接字列表、发数据套接字列表、异常套接字列表</strong>。<br>返回值分别对应这3个列表，返回的第一个列表是收数据套接字列表中等待接收数据的套接字组成的列表；返回的第二个列表是等待数据发送的套接字组成的列表；返回的第三个值是产生了异常等待处理的套接字列表。<br>select会以轮询(轮流查询，也就是要遍历列表)的方式来检测每个列表，然后将需要操作的套接字返回在列表当中。<br><strong>注意</strong>：select函数会产生阻塞，只有当传入的套接字列表有数据读写变化，select函数才会解阻塞。<br>下面就是一个select服务器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> select <span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 设置重复绑定</span></span><br><span class="line">serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绑定并将套接字设置为被动监听</span></span><br><span class="line">address = (<span class="string">&quot;&quot;</span>, <span class="number">8888</span>)</span><br><span class="line">serSocket.bind(address)</span><br><span class="line">serSocket.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录所有可接收数据的套接字</span></span><br><span class="line">inputs = [serSocket]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 调用select函数，阻塞等待，只要有套接字的变化解阻塞</span></span><br><span class="line">    readable,writeable,exceptional = select(inputs,[],[])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有可接收数据的套接字</span></span><br><span class="line">    <span class="keyword">for</span> sock <span class="keyword">in</span> readable:</span><br><span class="line">        <span class="comment"># 如果是服务器套接字发生变化，则代表有新的连接出现</span></span><br><span class="line">        <span class="keyword">if</span> sock == serSocket:</span><br><span class="line">            newSocket,clientInfo = serSocket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s connected...&quot;</span> %<span class="built_in">str</span>(clientInfo))</span><br><span class="line">            inputs.append(newSocket)</span><br><span class="line">        <span class="comment"># 如果是客户端的套接字发生变化，则表示有数据传递</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;--- closed ---&quot;</span>)</span><br><span class="line">                sock.close()</span><br><span class="line">                inputs.remove(sock)</span><br><span class="line"></span><br><span class="line">serSocket.close()</span><br></pre></td></tr></table></figure><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。<br>还有，当套接字比较多的时候，每次select()都要通过遍历很多个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<br><strong>因此select基本上没什么卵用，它不能用作高并发的服务器。</strong></p><h3 id="epoll-服务器"><a href="#epoll-服务器" class="headerlink" title="epoll 服务器"></a>epoll 服务器</h3><blockquote><p>上面说过，select有最大数量限制。<br>而poll则解决了这个问题，但是poll和select一样都是采用的轮询的机制来对套接字列表进行检测的，这样会使得服务器的效率变得低下。<br>因此poll也不常用，这里只是和select函数做一个比较。<br>而这一节要说的是epoll服务器，这个是poll的一个增强版本，它不仅没有最大数量限制(这只是理论上的，实际上还要根据内存的大小来考虑)，也不是通过轮询方式进行检测，而是通过事件通知机制来检测套接字是否发生了变化。<br>轮询相当于一个一个的去问有没有变化，事件通知机制则是套接字自己说自己有没有变化。<br>这样一来，效率就比select和poll要高了。</p></blockquote><p>epoll是select模块中的一个类，其中有2个比较重要的方法分别是register和poll。<br>register用法如下：<br><code>register(fd[, eventmask]) -&gt; None</code><br>其中的fd为文件描述符(详情见C语言中的文件描述符)，eventmask为对文件描述符对应的文件的操作，常见的有EPOLLIN, EPOLLOUT, EPOLLET, EPOLLPRO。其中的in和out为可读和可写，后面两种分别为：<br>ET模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll时，不会再次响应应用程序并通知此事件。<br>LT模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll时，会再次响应应用程序并通知此事件。<br>注意：如果fd已经注册过，这里会发生异常。<br>poll用法如下：<br><code>poll([timeout=-1[, maxevents=-1]]) -&gt; [(fd, events), (...)]</code><br>poll方法和select方法一样，阻塞（如果没有指定超时时间），然后对注册的文件描述符（这里是套接字）进行扫描，一有套接字变化的通知立马解开阻塞。<br>epoll服务器案例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字等基本操作</span></span><br><span class="line">serSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">address = (<span class="string">&quot;&quot;</span>, <span class="number">8888</span>)</span><br><span class="line">serSocket.bind(address)</span><br><span class="line">serSocket.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对象</span></span><br><span class="line">epl = select.epoll()</span><br><span class="line"><span class="comment"># 将服务器套接字注册到epl中（也就是将套接字添加到epl的事件监听中）</span></span><br><span class="line">epl.register(serSocket.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置两个字典用于保存连接的套接字和信息</span></span><br><span class="line">connections = &#123;&#125;</span><br><span class="line">addrInfo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 阻塞，当有套接字产生事件的时候解阻塞，并返回所有产生套接字事件的fd和事件</span></span><br><span class="line">    epoll_list = epl.poll()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fd,events <span class="keyword">in</span> epoll_list:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 如果是服务器套接字产生事件，那么代表有新的连接</span></span><br><span class="line">        <span class="keyword">if</span> fd == serSocket.fileno():</span><br><span class="line">            newSocket,clientInfo = serSocket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s connected...&quot;</span> %<span class="built_in">str</span>(clientInfo))</span><br><span class="line">            connections[newSocket.fileno()] = newSocket</span><br><span class="line">            addrInfo[newSocket.fileno()] = clientInfo</span><br><span class="line">            <span class="comment"># 将新的套接字注册到epl中</span></span><br><span class="line">            epl.register(newSocket.fileno(), select.EPOLLIN|select.EPOLLET)</span><br><span class="line">        <span class="comment"># 如果是其他的套接字产生事件，则代表有数据接收</span></span><br><span class="line">        <span class="keyword">elif</span> events == select.EPOLLIN:</span><br><span class="line">            recvData = connections[fd].recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> recvData:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> %(<span class="built_in">str</span>(addrInfo[fd]),recvData.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 套接字关闭后解除注册</span></span><br><span class="line">                epl.unregister(fd)</span><br><span class="line">                connections[fd].close()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s closed...&quot;</span> %<span class="built_in">str</span>(addrInfo[fd]))</span><br><span class="line">                <span class="keyword">del</span> connections[fd]</span><br><span class="line">                <span class="keyword">del</span> addrInfo[fd]</span><br><span class="line"></span><br><span class="line">setsockopt.close()</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法(英语：Regular Expression，在代码中常简写为regex、regexp或RE)，是计算机科学的一个概念。<br>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。<br>Regular Expression的”Regular”一般被译为”正则”、”正规”、”常规”。此处的”Regular”即是”规则”、”规律”的意思，Regular Expression即”描述某种规则的表达式”之意。</p><h3 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h3><p>在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块，名字为<code>re</code><br>因此要使用re模块中的内容，首先要导入re模块：<br><code>import re</code><br>re模块中有个方法为match，使用方法如下：<br><code>match(pattern, string, flags=0)</code><br>第一个参数pattern为正则表达式，第二个参数为要匹配的字符串（一般就使用这两个参数）。<br>match方法会从字符串的开头处开始用正则表达式对其匹配，如果能完整的匹配正则表达式中的所有内容，则会返回匹配对象，否则返回None。<br>在返回的对象中，可以使用group方法来查看匹配到的内容。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = re.match(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret.group()</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><blockquote><p>字符串中的反斜杠”&quot;在某些地方是作为转义字符来使用的。<br>正则表达式里也是使用”&quot;作为转义字符，这就可能造成反斜杠困扰。<br>假如你需要匹配文本中的字符”&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。<br>Python里的原生字符串很好地解决了这个问题，有了原始字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。<br>如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&quot;C:\\a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">C:\a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(re.match(<span class="string">&quot;C:\\\\a&quot;</span>,<span class="built_in">str</span>).group())</span><br><span class="line">C:\a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(re.match(<span class="string">r&quot;C:\\a&quot;</span>,<span class="built_in">str</span>).group())</span><br><span class="line">C:\a</span><br></pre></td></tr></table></figure><p><strong>要使用原始字符串只需要在字符串前加上一个r字母即可</strong></p><h3 id="正则表达式匹配规则"><a href="#正则表达式匹配规则" class="headerlink" title="正则表达式匹配规则"></a>正则表达式匹配规则</h3><ul><li><p><strong>字符匹配</strong></p><table><thead><tr><th align="center">字符</th><th>功能</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配任意一个字符，’\n’除外，在DOTALL模式中可以匹配’\n’</td></tr><tr><td align="center">[…]</td><td>匹配中括号中列举的所有字符，可使用0-9之类的范围</td></tr><tr><td align="center">\d</td><td>匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td>匹配非数字</td></tr><tr><td align="center">\s</td><td>匹配空白(\n \r \t之类的可以匹配)</td></tr><tr><td align="center">\S</td><td>匹配非空白</td></tr><tr><td align="center">\w</td><td>匹配单词字符，即a-zA-Z0-9_</td></tr><tr><td align="center">\W</td><td>匹配非单词字符</td></tr></tbody></table></li><li><p><strong>数量匹配</strong></p><table><thead><tr><th align="center">字符</th><th>功能</th></tr></thead><tbody><tr><td align="center">*</td><td>匹配前一个字符出现任意次(包括0次)</td></tr><tr><td align="center">+</td><td>匹配前一个字符至少一次</td></tr><tr><td align="center">?</td><td>匹配前一个字符0或1次</td></tr><tr><td align="center">{m}</td><td>匹配前一个字符出现m次(正好m次)</td></tr><tr><td align="center">{m,}</td><td>匹配前一个字符至少m次</td></tr><tr><td align="center">{m,n}</td><td>匹配前一个字符m到n次</td></tr></tbody></table></li><li><p><strong>表示边界</strong></p><table><thead><tr><th align="center">字符</th><th>功能</th></tr></thead><tbody><tr><td align="center">^</td><td>匹配字符串开头</td></tr><tr><td align="center">$</td><td>匹配字符串结尾</td></tr><tr><td align="center">\b</td><td>匹配一个单词的边界</td></tr><tr><td align="center">\B</td><td>匹配非单词边界</td></tr></tbody></table></li><li><p><strong>匹配分组</strong></p><table><thead><tr><th align="center">字符</th><th>功能</th></tr></thead><tbody><tr><td align="center">|</td><td>匹配左右任意一个表达式(一般用于分组)</td></tr><tr><td align="center">()</td><td>将括号中字符串作为一个分组</td></tr><tr><td align="center">\NUM</td><td>引用第NUM个分组</td></tr><tr><td align="center">(?P&lt;NAME&gt;…)</td><td>给分组起别名</td></tr><tr><td align="center">(?P&#x3D;NAME)</td><td>引用别名为NAME的分组</td></tr></tbody></table><p>注意：在用分组进行匹配的时候，可以用<code>group</code>方法来打印匹配到的分组，<br>如group(1)就是打印第一个分组，group(2)就是打印第二个分组，以此类推。</p></li></ul><h3 id="re-模块中的其他函数"><a href="#re-模块中的其他函数" class="headerlink" title="re 模块中的其他函数"></a>re 模块中的其他函数</h3><ul><li><p><strong>search</strong><br>search和match的使用方法是一样的，唯一不同的是match是从字符串第一个字符开始匹配的，而search可以从任意地方进行匹配<br><strong>注意</strong>：search只匹配一个，返回第一个匹配到的<br>search使用方法如下：<br><code>search(pattern, string, flags=0)</code></p></li><li><p><strong>findall</strong><br>findall和search类似，不过findall是将所有匹配到的字符串组成一个列表返回。<br>使用方法如下：<br><code>findall(pattern, string, flags=0)</code></p></li><li><p><strong>sub</strong><br>sub方法可以将匹配到的字符串进行替换，返回结果为替换之后的结果。<br>使用方法如下：<br><code>sub(pattern, repl, string, count=0, flags=0)</code><br>其中的repl可以是替换后的字符串，也可以是一个替换规则(即函数引用)。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;1000&quot;</span>, <span class="string">&quot;python = 238&quot;</span>)</span><br><span class="line"><span class="string">&#x27;python = 1000&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">temp</span>):</span><br><span class="line"><span class="meta">... </span>    r = <span class="built_in">int</span>(temp.group()) + <span class="number">100</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="built_in">str</span>(r)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&quot;\d+&quot;</span>, add, <span class="string">&quot;python = 1234&quot;</span>)</span><br><span class="line"><span class="string">&#x27;python = 1334&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>split</strong><br>split函数会根据匹配进行字符串的切割，并且返回一个列表。使用方法如下：<br><code>split(pattern, string, maxsplit=0, flags=0)</code><br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r&#x27;:| &#x27;</span>, <span class="string">&quot;info:LaoWang 33 ShangHai&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;LaoWang&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;ShangHai&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h3><p>在Python中正则表达式的匹配中，默认是<strong>贪婪</strong>的(总是尝试匹配尽可能多的字符)。<strong>非贪婪</strong>则相反，总是匹配尽可能少的字符。<br>那么哪些规则字符会匹配尽可能多的字符呢？<br>有 <code>*、?、+、&#123;m,n&#125;</code>, 这些规则会尽可能的匹配更多字符，我们可以在这些字符后面再加上一个<code>?</code>，那么这些规则字符就会从贪婪模式变为非贪婪模式。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;This number is 234-235-838-181&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;.*(\d+-\d+-\d+-\d+)&quot;</span>, s).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;4-235-838-181&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;.*?(\d+-\d+-\d+-\d+)&quot;</span>, s).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;234-235-838-181&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;aa(\d+)&quot;</span>, <span class="string">&quot;aa1234ddd&quot;</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;aa(\d+?)&quot;</span>, <span class="string">&quot;aa1234ddd&quot;</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;aa(\d+)ddd&quot;</span>, <span class="string">&quot;aa1234ddd&quot;</span>).group(<span class="number">1</span>) </span><br><span class="line"><span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r&quot;aa(\d+?)ddd&quot;</span>, <span class="string">&quot;aa1234ddd&quot;</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：所谓的非贪婪也要在能完整匹配字符串的前提下尽可能少的匹配字符。</p><h2 id="web-服务器案例"><a href="#web-服务器案例" class="headerlink" title="web 服务器案例"></a>web 服务器案例</h2><p>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：</p><blockquote><p>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；<br>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</p></blockquote><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>浏览器通过HTTP协议连接到服务器的时候，会发送一个请求报文。<br>其中最主要的头两行分析如下：<br>第一行如：<br><code>GET / HTTP/1.1</code></p><blockquote><p>GET表示一个读取请求，将从服务器获得网页数据<br>&#x2F;表示URL的路径，URL总是以&#x2F;开头，&#x2F;就表示首页<br>最后的HTTP&#x2F;1.1指示采用的HTTP协议版本是1.1<br>目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p></blockquote><p>HTTP所有的<strong>请求方式</strong>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET：请求获取数据</span><br><span class="line">POST：请求修改数据</span><br><span class="line">PUT：请求保存数据</span><br><span class="line">DELETE：请求删除数据</span><br><span class="line">OPTION：询问服务器的某种支持特性</span><br><span class="line">HEAD：请求返回报文头</span><br></pre></td></tr></table></figure><p>从第二行开始，每一行都是以KEY:VALUE的形式（类似于字典）。一般开始是：<br><strong>Host: <a target="_blank" rel="noopener" href="http://www.xxx.com/">www.xxx.com</a></strong><br>这个表示请求的域名</p><p>客户端请求之后服务器需要给出响应，HTTP响应分为Header和Body两部分(Body是可选项)。最重要的几行如下：<br><code>HTTP/1.1 200 OK</code><br>200表示一个成功的响应，OK是一个说明。<br>如果返回的不是200，那么往往有其他的功能，例如<strong>失败</strong>的响应有:<br><strong>404 Not Found</strong>：网页不存在<br><strong>500 Internal Server Error</strong>：服务器内部出错<br>…等等…</p><p><code>Content-Type: text/html</code><br>Content-Type指示响应的内容，这里是text&#x2F;html表示HTML网页。<br>请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。<br>浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://www.baidu.com/meimei.jpg</code>，它也不一定就是图片。</p><p>HTTP响应的<strong>Body</strong>就是HTML源码，也就是通过浏览器看到的东西。</p><h3 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h3><ul><li><p><strong>GET请求格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br></pre></td></tr></table></figure><p>每个Header一行一个，换行符是\r\n。</p></li><li><p><strong>POST请求格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure><p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body。</p></li><li><p><strong>服务器响应格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure><p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。<br>请再次注意，Body的数据类型由<strong>Content-Type</strong>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。<br>当存在<strong>Content-Encoding</strong>时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p></li></ul><h3 id="Web-静态服务器"><a href="#Web-静态服务器" class="headerlink" title="Web 静态服务器"></a>Web 静态服务器</h3><ul><li><p><strong>显示固定页面</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleClient</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理客户端请求线程&quot;&quot;&quot;</span></span><br><span class="line">    request_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span> %request_data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 构造服务器响应报文</span></span><br><span class="line">    response_start_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">    response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">    response_body = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    response = response_start_line + response_headers + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s\n&quot;</span> %response)</span><br><span class="line">    <span class="comment"># 向客户端发送响应数据</span></span><br><span class="line">    client_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 关闭客户端连接</span></span><br><span class="line">    client_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    address = (<span class="string">&quot;&quot;</span>, <span class="number">8000</span>)</span><br><span class="line">    server_socket.bind(address)</span><br><span class="line">    server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收客户端请求</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket,client_addr = server_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s:%d connected...\n&quot;</span> %(client_addr[<span class="number">0</span>], client_addr[<span class="number">1</span>]))</span><br><span class="line">        new_thread = Thread(target=handleClient, args=(client_socket,))</span><br><span class="line">        new_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p><strong>显示静态文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- py ----</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态文件根目录</span></span><br><span class="line">HTML_ROOT_DIR = <span class="string">&quot;./html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleClient</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理客户端请求线程&quot;&quot;&quot;</span></span><br><span class="line">    request_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">    request_lines = request_data.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines()</span><br><span class="line">    <span class="comment">#for line in request_lines:</span></span><br><span class="line">        <span class="comment">#print(line)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取请求报文的起始行</span></span><br><span class="line">    request_start_line = request_lines[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 用正则表达式获取起始行路径</span></span><br><span class="line">    file_name = re.match(<span class="string">r&quot;[A-Z]+ +(/[^ ]*) &quot;</span>, request_start_line).group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> == file_name:</span><br><span class="line">        file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开文件，读取内容</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fr = <span class="built_in">open</span>(HTML_ROOT_DIR + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="comment"># 如果文件不存在则发送404报文</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response_start_line = <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span></span><br><span class="line">        response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">        response_body = <span class="string">&quot;The file is not found!&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        file_data = fr.read()</span><br><span class="line">        fr.close()</span><br><span class="line">        <span class="comment"># 构造服务器响应报文</span></span><br><span class="line">        response_start_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">        response_body = file_data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    response = response_start_line + response_headers + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向客户端发送响应数据</span></span><br><span class="line">    client_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 关闭客户端连接</span></span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    address = (<span class="string">&quot;&quot;</span>, <span class="number">8000</span>)</span><br><span class="line">    server_socket.bind(address)</span><br><span class="line">    server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收客户端请求</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket,client_addr = server_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s:%d connected...\n&quot;</span> %(client_addr[<span class="number">0</span>], client_addr[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment">#handleClient(client_socket)</span></span><br><span class="line">        new_thread = Thread(target=handleClient, args=(client_socket,))</span><br><span class="line">        new_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p><strong>面向对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">self, client_socket</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;</span></span><br><span class="line">        request_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">        request_lines = request_data.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines()</span><br><span class="line">        <span class="comment">#for line in request_lines:</span></span><br><span class="line">            <span class="comment">#print(line)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取请求报文的起始行</span></span><br><span class="line">        request_start_line = request_lines[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用正则表达式获取起始行路径</span></span><br><span class="line">        file_name = re.match(<span class="string">r&quot;[A-Z]+ +(/[^ ]*) &quot;</span>, request_start_line).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> == file_name:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开文件，读取内容</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fr = <span class="built_in">open</span>(HTML_ROOT_DIR + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果文件不存在则发送404报文</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            response_start_line = <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span></span><br><span class="line">            response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">            response_body = <span class="string">&quot;The file is not found!&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_data = fr.read()</span><br><span class="line">            fr.close()</span><br><span class="line">            <span class="comment"># 构造服务器响应报文</span></span><br><span class="line">            response_start_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">            response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">            response_body = file_data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        response = response_start_line + response_headers + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向客户端发送响应数据</span></span><br><span class="line">        client_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 关闭客户端连接</span></span><br><span class="line">        client_socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动服务&quot;&quot;&quot;</span></span><br><span class="line">        self.server_socket.listen(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># 接收客户端请求</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket,client_addr = self.server_socket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:%d connected...\n&quot;</span> %(client_addr[<span class="number">0</span>], client_addr[<span class="number">1</span>]))</span><br><span class="line">            <span class="comment">#handleClient(client_socket)</span></span><br><span class="line">            new_thread = Thread(target=self.handle_client, args=(client_socket,))</span><br><span class="line">            new_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">self, port</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;绑定端口&quot;&quot;&quot;</span></span><br><span class="line">        address = (<span class="string">&quot;&quot;</span>, port)</span><br><span class="line">        self.server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态文件根目录</span></span><br><span class="line">HTML_ROOT_DIR = <span class="string">&quot;./html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    http_server = HTTPServer()</span><br><span class="line">    http_server.bind(<span class="number">8000</span>)</span><br><span class="line">    http_server.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Web-动态服务器"><a href="#Web-动态服务器" class="headerlink" title="Web 动态服务器"></a>Web 动态服务器</h3><p>我们上面写的服务器是静态服务器，只能返回静态的资源给客户端。<br>那么我们如何响应HTTP客户端请求动态资源呢？<br>服务器可以通过wsgi调用一个属性，那么什么是wsgi呢？</p><blockquote><p>wsgi：Web Server Gateway Interface (或简称 WSGI，读作“wizgy”)。<br>WSGI允许开发者将选择web框架和web服务器分开。<br>可以混合匹配web服务器和web框架，选择一个适合的配对。<br>比如,可以在Gunicorn 或者 Nginx&#x2F;WSGI 或者 Waitress上运行 Django, Flask, 或 Pyramid。<br>真正的混合匹配，得益于WSGI同时支持服务器和架构。<br>web服务器必须具备WSGI接口，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同工作。</p><p>WSGI由web服务器支持，而web框架允许你选择适合自己的配对，但它同样对于服务器和框架开发者提供便利使他们可以专注于自己偏爱的领域和专长而不至于相互牵制。<br>其他语言也有类似接口：java有Servlet API，Ruby 有 Rack。</p><p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。<br>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">   start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p><ul><li>environ：一个包含所有HTTP请求信息的dict对象；</li><li>start_response：一个发送HTTP响应的函数。</li></ul><p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，把底层web服务器解析部分和应用程序逻辑部分进行了分离，这样开发者就可以专心做一个领域了。<br>但是，这个application函数怎么调用呢？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。<br>所以application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器。而我们此时的web服务器项目的目的就是做一个极可能解析静态网页还可以解析动态网页的服务器。<br>注意：WSGI中的application函数需要返回响应体。</p></blockquote><ul><li><p><strong>WSGI服务器简单案例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        self.response_header = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, headers</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对报文头部进行处理&quot;&quot;&quot;</span></span><br><span class="line">        response_headers = <span class="string">&quot;HTTP/1.1 &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> headers:</span><br><span class="line">            response_headers += <span class="string">&quot;%s: %s\r\n&quot;</span> %heaser</span><br><span class="line">        self.response_header = response_headers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">self, client_socket</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;</span></span><br><span class="line">        request_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        request_lines = request_data.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines()</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 获取请求报文的起始行</span></span><br><span class="line">        request_start_line = request_lines[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用正则表达式获取起始行路径</span></span><br><span class="line">        file_name = re.match(<span class="string">r&quot;[A-Z]+ +(/[^ ]*) &quot;</span>, request_start_line).group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理客户端获取动态资源的请求</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 导入客户请求资源的模块</span></span><br><span class="line">            <span class="keyword">if</span> file_name.endswith(<span class="string">&quot;.py&quot;</span>):</span><br><span class="line">                m = <span class="built_in">__import__</span>(file_name[<span class="number">1</span>:-<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m = <span class="built_in">__import__</span>(file_name[<span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># 获取动态资源失败之后尝试获取静态资源</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> == file_name:</span><br><span class="line">                file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 打开文件，读取内容</span></span><br><span class="line">                fr = <span class="built_in">open</span>(HTML_ROOT_DIR + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">            <span class="comment"># 如果文件不存在则发送404报文</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                response_start_line = <span class="string">&quot;HTTP/1.1 404 Not Found\r\n&quot;</span></span><br><span class="line">                response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">                response_body = <span class="string">&quot;The file is not found!&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_data = fr.read()</span><br><span class="line">                fr.close()</span><br><span class="line">                <span class="comment"># 构造服务器响应报文</span></span><br><span class="line">                response_start_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                response_headers = <span class="string">&quot;Server: Janvy&#x27;s server\r\n&quot;</span></span><br><span class="line">                response_body = file_data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">            response = response_start_line + response_headers + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line">        <span class="comment"># 成功导入模块则通过WSGI调用模块内接口</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            env = &#123;&#125;</span><br><span class="line">            response_body = m.application(env, self.start_response)</span><br><span class="line">            response = self.response_header + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向客户端发送响应数据</span></span><br><span class="line">        client_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 关闭客户端连接</span></span><br><span class="line">        client_socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动服务&quot;&quot;&quot;</span></span><br><span class="line">        self.server_socket.listen(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># 接收客户端请求</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket,client_addr = self.server_socket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:%d connected...\n&quot;</span> %(client_addr[<span class="number">0</span>], client_addr[<span class="number">1</span>]))</span><br><span class="line">            <span class="comment">#self.handle_client(client_socket)</span></span><br><span class="line">            new_thread = Thread(target=self.handle_client, args=(client_socket,))</span><br><span class="line">            new_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">self, port</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;绑定端口&quot;&quot;&quot;</span></span><br><span class="line">        address = (<span class="string">&quot;&quot;</span>, port)</span><br><span class="line">        self.server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态文件根目录</span></span><br><span class="line">HTML_ROOT_DIR = <span class="string">&quot;./html&quot;</span></span><br><span class="line"><span class="comment"># 设置WSGI脚本目录</span></span><br><span class="line">WSGI_DIR = <span class="string">&quot;./wsgipython&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys.path = [WSGI_DIR]</span><br><span class="line">    <span class="comment">#sys.path.insert(1,WSGI_DIR) </span></span><br><span class="line">    http_server = HTTPServer()</span><br><span class="line">    http_server.bind(<span class="number">8000</span>)</span><br><span class="line">    http_server.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>wsgi中的ctime模块如下：<br>ctime.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line">              </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">env, start_response</span>):</span><br><span class="line">    status = <span class="string">&quot;200 OK&quot;</span></span><br><span class="line">    headers = [ </span><br><span class="line">        (<span class="string">&quot;Contect-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">    ]         </span><br><span class="line">    <span class="keyword">return</span> ctime()</span><br></pre></td></tr></table></figure></li><li><p><strong>服务器框架</strong><br>我们了解到，WSGI服务器可以让服务器响应客户端发出的动态资源请求。<br>但是WSGI中的每个接口都要单独定义一个文件，这样就让我们的服务器变得繁琐，可移植性也会下降。<br>因此我们需要封装所有的模块到一个模块中，这样就形成了一个框架。<br>框架案例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态文件根目录</span></span><br><span class="line">HTML_DIR = <span class="string">&quot;./html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;框架&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, urls</span>):</span><br><span class="line">        <span class="comment"># 设置路由信息</span></span><br><span class="line">        self.urls = urls</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, env, start_response</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置call方法可以让类像函数一样调用，这里就是WSGI中的app函数&quot;&quot;&quot;</span></span><br><span class="line">        path = env.get(<span class="string">&quot;PATH_INFO&quot;</span>)</span><br><span class="line">        headers = [</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> == path <span class="keyword">or</span> <span class="string">&quot;/index.html&quot;</span> == path:</span><br><span class="line">            path = <span class="string">&quot;/static/index.html&quot;</span></span><br><span class="line">        <span class="comment"># 访问静态文件时</span></span><br><span class="line">        <span class="keyword">if</span> path.startswith(<span class="string">&quot;/static&quot;</span>):</span><br><span class="line">            file_name = path[<span class="number">7</span>:]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fr = <span class="built_in">open</span>(HTML_DIR + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_data = fr.read()</span><br><span class="line">                fr.close()</span><br><span class="line">                status = <span class="string">&quot;200 OK&quot;</span></span><br><span class="line">                start_response(status, headers)</span><br><span class="line">                <span class="keyword">return</span> file_data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="comment"># 请求静态资源</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> url,handler <span class="keyword">in</span> self.urls:</span><br><span class="line">                <span class="keyword">if</span> path == url:</span><br><span class="line">                    <span class="keyword">return</span> handler(env, start_response)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果静态资源和动态资源都没有找到</span></span><br><span class="line">        status = <span class="string">&quot;404 Not Found&quot;</span></span><br><span class="line">        start_response(status, headers)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;body&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/body&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_ctime</span>(<span class="params">env, start_response</span>):</span><br><span class="line">    status = <span class="string">&quot;200 OK&quot;</span></span><br><span class="line">    headers = [</span><br><span class="line">        (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">    start_response(status, headers)</span><br><span class="line">    <span class="keyword">return</span> ctime()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">env, start_response</span>):</span><br><span class="line">    status = <span class="string">&quot;200 OK&quot;</span></span><br><span class="line">    headers = [</span><br><span class="line">        (<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">    start_response(status, headers)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    (<span class="string">&quot;/ctime&quot;</span>, show_ctime),</span><br><span class="line">    (<span class="string">&quot;/sayhello&quot;</span>, say_hello)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app = Application(urls)</span><br></pre></td></tr></table></figure><p>定义好框架后我们可以让服务器调用这个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app</span>):</span><br><span class="line">        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        self.app = app</span><br><span class="line">        self.response_header = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, headers</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对报文头部进行处理&quot;&quot;&quot;</span></span><br><span class="line">        response_headers = <span class="string">&quot;HTTP/1.1 &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> headers:</span><br><span class="line">            response_headers += <span class="string">&quot;%s: %s\r\n&quot;</span> %header</span><br><span class="line">        self.response_header = response_headers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">self, client_socket</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理客户端请求&quot;&quot;&quot;</span></span><br><span class="line">        request_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        request_lines = request_data.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取请求报文的起始行</span></span><br><span class="line">        request_start_line = request_lines[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用正则表达式获取起始行路径</span></span><br><span class="line">        file_name = re.match(<span class="string">r&quot;[A-Z]+ +(/[^ ]*) &quot;</span>, request_start_line).group(<span class="number">1</span>)</span><br><span class="line">        method = re.match(<span class="string">r&quot;([A-Z]+) +/[^ ]* &quot;</span>, request_start_line).group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理客户端获取资源的请求</span></span><br><span class="line">        env = &#123;</span><br><span class="line">            <span class="string">&quot;PATH_INFO&quot;</span>:file_name,</span><br><span class="line">            <span class="string">&quot;METHOD&quot;</span>:method</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 调用框架解决资源请求</span></span><br><span class="line">        response_body = self.app(env, self.start_response)</span><br><span class="line">        response = self.response_header + <span class="string">&quot;\r\n&quot;</span> + response_body</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向客户端发送响应数据</span></span><br><span class="line">        client_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 关闭客户端连接</span></span><br><span class="line">        client_socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动服务&quot;&quot;&quot;</span></span><br><span class="line">        self.server_socket.listen(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># 接收客户端请求</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket,client_addr = self.server_socket.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:%d connected...\n&quot;</span> %(client_addr[<span class="number">0</span>], client_addr[<span class="number">1</span>]))</span><br><span class="line">            <span class="comment">#self.handle_client(client_socket)</span></span><br><span class="line">            new_thread = Thread(target=self.handle_client, args=(client_socket,))</span><br><span class="line">            new_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">self, port</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;绑定端口&quot;&quot;&quot;</span></span><br><span class="line">        address = (<span class="string">&quot;&quot;</span>, port)</span><br><span class="line">        self.server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    m = <span class="built_in">__import__</span>(<span class="string">&quot;MyWebFrameWork&quot;</span>)</span><br><span class="line">    http_server = HTTPServer(m.app)</span><br><span class="line">    http_server.bind(<span class="number">8000</span>)</span><br><span class="line">    http_server.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其中的<code>m = __import__</code>那里就是导入框架。<br>这样一来，我们不用去改写服务器的代码，响应报文全部交给框架来构建，我们只需要在调用不同的框架的时候改服务器中main函数中的import就行了。</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。<br>如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。<br>Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的<strong>内置数据结构</strong>，比如列表、元组、字典。<br>而有些数据组织方式，Python系统里面没有直接定义，需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。<br>这里的数据结构和C语言中的一样，不加赘述。</p></blockquote><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p><strong>单链表</strong></p><blockquote><p>单链表也叫单向链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。<br>这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。</p></blockquote><p>单链表的操作：</p><ul><li>is_empty() 链表是否为空</li><li>length() 链表长度</li><li>travel() 遍历整个链表</li><li>add(item) 链表头部添加元素</li><li>append(item) 链表尾部添加元素</li><li>insert(pos, item) 指定位置添加元素</li><li>remove(item) 删除节点</li><li>search(item) 查找节点是否存在</li></ul><p>下面以Python代码来实现这个单链表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item  <span class="comment">#item用于储存数据</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment">#next用于指向下一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化链表&quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node(<span class="literal">None</span>)</span><br><span class="line">        self.count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The LinkList is: &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_node != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s &quot;</span> %cur_node.item, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head</span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;pos:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span>.item != item:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ll = LinkList()</span><br><span class="line">    ll.add(<span class="number">8</span>)</span><br><span class="line">    ll.add(<span class="number">7</span>)</span><br><span class="line">    ll.add(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">5</span>)</span><br><span class="line">    ll.add(<span class="number">4</span>)</span><br><span class="line">    ll.add(<span class="number">3</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">9</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    ll.remove(<span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">5</span>))</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The LinkList is: 1 2 3 4 5 6 7 8 9 </span><br><span class="line">LinkList&#x27;s length is 9</span><br><span class="line">The LinkList is: 1 2 3 4 6 7 8 9 </span><br><span class="line">LinkList&#x27;s length is 8</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">The LinkList is: 1 2 3 4 5 6 7 8 9 </span><br><span class="line">LinkList&#x27;s length is 9</span><br></pre></td></tr></table></figure></li><li><p><strong>单向循环链表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item  <span class="comment">#item用于储存数据</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment">#next用于指向下一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CycLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化链表&quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 循环链接</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The LinkList is: &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_node != self.head:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s &quot;</span> %cur_node.item, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span> != self.head:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head</span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;pos:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span>.item != item:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node != self.head:</span><br><span class="line">            <span class="keyword">if</span> cur_node.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ll = CycLinkList()</span><br><span class="line">    ll.add(<span class="number">8</span>)</span><br><span class="line">    ll.add(<span class="number">7</span>)</span><br><span class="line">    ll.add(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">5</span>)</span><br><span class="line">    ll.add(<span class="number">4</span>)</span><br><span class="line">    ll.add(<span class="number">3</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">9</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    ll.remove(<span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">5</span>))</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行结果和上面一样</p></li><li><p><strong>双向链表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.item = item  <span class="comment">#item用于储存数据</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment">#next用于指向下一个节点</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化链表&quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node(<span class="literal">None</span>)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The LinkList is: &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_node != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s &quot;</span> %cur_node.item, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从链表头部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        new_node.prev = self.head</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; <span class="number">0</span>:</span><br><span class="line">            self.head.<span class="built_in">next</span>.prev = new_node</span><br><span class="line"></span><br><span class="line">        self.head.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        new_node.prev = cur_node</span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, pos, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置插入元素&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head</span><br><span class="line">        new_node = Node(item)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;pos:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span></span><br><span class="line">        new_node.prev = cur_node</span><br><span class="line">        cur_node.<span class="built_in">next</span>.prev = new_node</span><br><span class="line">        cur_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除指定节点&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span>.item != item:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        cur_node.<span class="built_in">next</span>.<span class="built_in">next</span>.prev = cur_node</span><br><span class="line">        cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur_node = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur_node != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">8</span>)</span><br><span class="line">    ll.add(<span class="number">7</span>)</span><br><span class="line">    ll.add(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">5</span>)</span><br><span class="line">    ll.add(<span class="number">4</span>)</span><br><span class="line">    ll.add(<span class="number">3</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">9</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    ll.remove(<span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(ll.search(<span class="number">5</span>))</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LinkList&#x27;s length is %s&quot;</span>%ll.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行结果和上面一样</p></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>栈(stack)，有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素<br>它的特点在于只能允许在容器的一端(称为栈顶端)进行加入数据和输出数据的运算。<br>它没有位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。<br>由于栈数据结构只允许在一端进行操作，因而按照后进先出(LIFO, Last In First Out)的原理运作。</p></blockquote><p>我们以顺序表来构建一个栈，其功能如下：</p><ul><li>Stack() 创建一个新的空栈</li><li>push(item) 添加一个新的元素item到栈顶</li><li>pop() 弹出栈顶元素</li><li>peek() 返回栈顶元素</li><li>is_empty() 判断栈是否为空</li><li>size() 返回栈的元素个数</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序栈&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;放入元素到栈中&quot;&quot;&quot;</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹出栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.items[self.size()-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.size() == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    stack = MyStack()</span><br><span class="line">    stack.push(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    stack.push(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    stack.push(<span class="string">&quot;itcast&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(stack.size())</span><br><span class="line">    <span class="built_in">print</span>(stack.peek())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">itcast</span><br><span class="line">itcast</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote><p>队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种先进先出的(First In First Out)的线性表，简称FIFO。<br>允许插入的一端为队尾，允许删除的一端为队头。<br><strong>队列不允许在中间部位进行操作</strong><br>假设队列是q&#x3D;（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。<br>这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p></blockquote><p>我们用顺序表来实现队列，其功能如下：</p><ul><li>Queue() 创建一个空的队列</li><li>enqueue(item) 往队列中添加一个item元素</li><li>dequeue() 从队列头部删除一个元素</li><li>is_empty() 判断一个队列是否为空</li><li>size() 返回队列的大小</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;队列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;往队列中添加元素&quot;&quot;&quot;</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除元素&quot;&quot;&quot;</span></span><br><span class="line">        ret = self.items[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> self.items[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ret </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.size() == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q = MyQueue()</span><br><span class="line">    q.enqueue(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    q.enqueue(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    q.enqueue(<span class="string">&quot;itcast&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(q.size())</span><br><span class="line">    <span class="built_in">print</span>(q.dequeue())</span><br><span class="line">    <span class="built_in">print</span>(q.dequeue())</span><br><span class="line">    <span class="built_in">print</span>(q.dequeue())</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">itcast</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote><p>排序算法(Sorting algorithm)是一种能将一串数据依照特定顺序进行排列的一种算法。<br>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。<br>也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。<br>不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。<br>不稳定排序算法可以被特别地实现为稳定。<br>作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，(比如上面的比较中加入第二个标准：第二个键值的大小)就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。</p></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>冒泡排序(Bubble Sort)是一种简单的排序算法。<br>它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p></blockquote><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>代码如下(升序)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sork</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[i+<span class="number">1</span>]:</span><br><span class="line">                array[i],array[i+<span class="number">1</span>] = array[i+<span class="number">1</span>],array[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    bubble_sork(array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before sort: [54, 26, 93, 17, 77, 31, 44, 55, 20]</span><br><span class="line">After sort: [17, 20, 26, 31, 44, 54, 55, 77, 93]</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>选择排序(Selection sort)是一种简单直观的排序算法。<br>它的工作原理如下:<br>首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置<br>然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。<br>以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。<br>如果某个元素位于正确的最终位置上，则它不会被移动。<br>选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。<br>在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p></blockquote><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        max_index = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> array[max_index] &lt; array[j]:</span><br><span class="line">                max_index = j </span><br><span class="line">        array[max_index],array[j] = array[j],array[max_index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    select_sort(array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果和上面一样</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>插入排序(Insertion Sort)是一种简单直观的排序算法。<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p></blockquote><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[j-<span class="number">1</span>]:</span><br><span class="line">                array[j],array[j-<span class="number">1</span>] = array[j-<span class="number">1</span>],array[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    insert_sort(array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果和上面一样</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>希尔排序(Shell Sort)是插入排序的一种。<br>也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。<br>希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列(步长更长了，列数更少了)来进行。<br>最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p></blockquote><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">array</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n): </span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            j = i </span><br><span class="line">            <span class="keyword">while</span> j&gt;=gap:</span><br><span class="line">                <span class="keyword">if</span> array[j-gap] &gt; array[j]:</span><br><span class="line">                    array[j-gap],array[j] = array[j],array[j-gap]</span><br><span class="line">                j -= gap </span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    shell_sort(array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果和上面相同</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>快速排序(Quicksort)，又称划分交换排序(partition-exchange sort)<br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”(pivot)</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。</li><li>递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。<br>虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">array, start, end</span>):</span><br><span class="line">    <span class="comment"># 退出递归</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span> array[start]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置基准值</span></span><br><span class="line">    key = array[start]</span><br><span class="line">    low = start</span><br><span class="line">    high = end </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> array[high]&gt;key:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        array[low] = array[high]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> array[low]&lt;key:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        array[high] = array[low]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳出循环后将基准值放在low和high相等的地方</span></span><br><span class="line">    array[low] = key </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对左字序列进行排序</span></span><br><span class="line">    quick_sort(array, start, low-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 对右子序列进行排序</span></span><br><span class="line">    quick_sort(array, low+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    quick_sort(array,<span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果和上面相同。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序是采用分治法的一个非常典型的应用。<br>归并排序的思想就是先递归分解数组，再合并数组。<br>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p></blockquote><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="comment"># 结束递归条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    num = <span class="built_in">len</span>(array) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    left = merge_sort(array[:num])</span><br><span class="line">    right = merge_sort(array[num:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并操作，将两个有序数组合并为一个大的有序数组&quot;&quot;&quot;</span></span><br><span class="line">    l_index,r_index = <span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l_index&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> r_index&lt;<span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[l_index] &lt; right[r_index]:</span><br><span class="line">            result.append(left[l_index])</span><br><span class="line">            l_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r_index])</span><br><span class="line">            r_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result += left[l_index:]</span><br><span class="line">    result += right[r_index:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before sort: %s&quot;</span>%array)</span><br><span class="line">    array = merge_sort(array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After sort: %s&quot;</span>%array)</span><br></pre></td></tr></table></figure><p>执行结果和上面相同。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Janvy Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://janvysun.github.io/python/8541a389-77d7-45ce-a30a-187778c6725a.html">https://janvysun.github.io/python/8541a389-77d7-45ce-a30a-187778c6725a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://janvysun.github.io" target="_blank">Janvy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="/images/hexo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/python/2eb6c6ca-e6ee-40b2-8aab-df84770e2b79.html"><img class="prev-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python 爬虫</div></div></a></div><div class="next-post pull-right"><a href="/python/4081a847-b578-4e2f-97df-b6e03bab216f.html"><img class="next-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/python/79f3fe31-f5c4-425b-9cd2-51993efc7e10.html" title="Python 入门"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-25</div><div class="title">Python 入门</div></div></a></div><div><a href="/python/894d516f-7aa7-4c9a-9060-6f2bbe95af74.html" title="Python 输入输出"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-27</div><div class="title">Python 输入输出</div></div></a></div><div><a href="/python/fedbf4b8-90d9-4204-a3bb-392957dd9e4b.html" title="Python 变量"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-26</div><div class="title">Python 变量</div></div></a></div><div><a href="/python/cbbc7563-8281-4bcc-a956-7a976dbf2643.html" title="Python 字符串"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-28</div><div class="title">Python 字符串</div></div></a></div><div><a href="/python/1827654a-05d2-4fda-8b4f-18279065c88d.html" title="Python 字典"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-01</div><div class="title">Python 字典</div></div></a></div><div><a href="/python/20125780-f44a-432b-868b-99d90124f74f.html" title="Python 列表、元组与集合"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-29</div><div class="title">Python 列表、元组与集合</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Janvy Sun</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/janvysun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:janvusun@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">1.1.</span> <span class="toc-text">import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-%E5%92%8C-x3D-x3D"><span class="toc-number">1.2.</span> <span class="toc-text">is 和 &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.</span> <span class="toc-text">进制和位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">私有化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property"><span class="toc-number">1.6.</span> <span class="toc-text">property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.9.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.11.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">1.12.</span> <span class="toc-text">Python 的动态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B1%BB"><span class="toc-number">1.13.</span> <span class="toc-text">元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.14.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">1.15.</span> <span class="toc-text">内建属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.</span> <span class="toc-text">内建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#functools"><span class="toc-number">1.17.</span> <span class="toc-text">functools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.18.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.19.</span> <span class="toc-text">编码风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">2.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getpid-%E5%92%8C-getppid"><span class="toc-number">2.2.</span> <span class="toc-text">getpid 和 getppid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">多进程中的全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process"><span class="toc-number">2.4.</span> <span class="toc-text">Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Process-%E5%AD%90%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">自定义 Process 子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool-%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.6.</span> <span class="toc-text">Pool 进程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.7.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">2.8.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.9.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#threading"><span class="toc-number">3.1.</span> <span class="toc-text">threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">自定义线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">多线程共享全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%85%B1%E4%BA%AB%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">线程不共享局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.6.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">3.7.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.8.</span> <span class="toc-text">生产者和消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.9.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL"><span class="toc-number">3.10.</span> <span class="toc-text">GIL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">4.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP"><span class="toc-number">4.1.</span> <span class="toc-text">TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">4.4.</span> <span class="toc-text">子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">4.5.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">4.6.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">4.7.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.8.</span> <span class="toc-text">TCP 单进程服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.9.</span> <span class="toc-text">并发服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.10.</span> <span class="toc-text">select 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.11.</span> <span class="toc-text">epoll 服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#re-%E6%A8%A1%E5%9D%97"><span class="toc-number">5.1.</span> <span class="toc-text">re 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.</span> <span class="toc-text">原始字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">5.3.</span> <span class="toc-text">正则表达式匹配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#re-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">re 模块中的其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA"><span class="toc-number">5.5.</span> <span class="toc-text">贪婪和非贪婪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">web 服务器案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.1.</span> <span class="toc-text">HTTP 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94"><span class="toc-number">6.2.</span> <span class="toc-text">HTTP 请求与响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">Web 静态服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">Web 动态服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">7.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">7.3.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">8.5.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.6.</span> <span class="toc-text">归并排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="世界が終るまでは…"></a><div class="content"><a class="title" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…">世界が終るまでは…</a><time datetime="2024-04-20T16:00:00.000Z" title="发表于 2024-04-21 00:00:00">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="我的世界攻略"></a><div class="content"><a class="title" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略">我的世界攻略</a><time datetime="2024-03-31T16:00:00.000Z" title="发表于 2024-04-01 00:00:00">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Nginx 的安装与使用"></a><div class="content"><a class="title" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用">Nginx 的安装与使用</a><time datetime="2024-03-10T16:00:00.000Z" title="发表于 2024-03-11 00:00:00">2024-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="真三国无双 7 攻略"></a><div class="content"><a class="title" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略">真三国无双 7 攻略</a><time datetime="2024-02-29T16:00:00.000Z" title="发表于 2024-03-01 00:00:00">2024-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker Compose 使用"></a><div class="content"><a class="title" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用">Docker Compose 使用</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By Janvy Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>