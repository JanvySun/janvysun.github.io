<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Java 面试题 | Janvy's blog</title><meta name="keywords" content="Java"><meta name="author" content="Janvy Sun"><meta name="copyright" content="Janvy Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章为本人整理的 Java 方向面试题，其中包含 JavaSE、JavaEE、SSM 框架、MySQL、网络、Redis 等内容的面试题及其答案。"><meta property="og:type" content="article"><meta property="og:title" content="Java 面试题"><meta property="og:url" content="https://janvysun.github.io/java/48704b01-97d8-4702-a476-d9e013ac36c2.html"><meta property="og:site_name" content="Janvy&#39;s blog"><meta property="og:description" content="这篇文章为本人整理的 Java 方向面试题，其中包含 JavaSE、JavaEE、SSM 框架、MySQL、网络、Redis 等内容的面试题及其答案。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://janvysun.github.io/images/hexo.png"><meta property="article:published_time" content="2020-07-26T16:00:00.000Z"><meta property="article:modified_time" content="2020-07-26T16:00:00.000Z"><meta property="article:author" content="Janvy Sun"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://janvysun.github.io/images/hexo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://janvysun.github.io/java/48704b01-97d8-4702-a476-d9e013ac36c2"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: [object Object]
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java 面试题",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-07-27 00:00:00"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background:linear-gradient(20deg,#0062be,#925696,#cc426e,#fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Janvy's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-26T16:00:00.000Z" title="发表于 2020-07-27 00:00:00">2020-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-26T16:00:00.000Z" title="更新于 2020-07-27 00:00:00">2020-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A2%98%E5%BA%93/">题库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java 面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><ul><li>JDK(Java Development Kit)，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE(Java Runtime Environment)，java 运行环境，为 java 的运行提供了所需环境。</li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><p><strong>final、finally、finalize 之间的区别</strong></p><ul><li>final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用 System 的 gc() 方法的时候，由垃圾回收器调用 finalize(),回收垃圾。</li></ul><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>Java5 以前 <code>switch(expression)</code> 中，expression 只能是 byte、short、char、int，严格意义上来讲 Java5 以前只支持 int，之所以能使用byte short char 是因为存在自动类型转换。从 Java 5 开始，Java 中引入了枚举类型，expression 也可以是 enum 类型。从 Java 7 开始，expression 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h3 id="amp-、-amp-amp"><a href="#amp-、-amp-amp" class="headerlink" title="&amp;、&amp;&amp;"></a>&amp;、&amp;&amp;</h3><ul><li>&amp; 运算符是：逻辑与；&amp;&amp; 运算符是：短路与。</li><li>&amp; 和 &amp;&amp; 在程序中最终的运算结果是完全一致的，只不过 &amp;&amp; 存在短路现象，当 &amp;&amp; 运算符左边的表达式结果为 false 的时候，右边的表达式不执行，此时就发生了短路现象。如果是 &amp; 运算符，那么不管左边的表达式是 true 还是 false，右边表达式是一定会执行的。这就是他们俩的本质区别。</li><li>当然，&amp; 运算符还可以使用在二进制位运算上，例如按位与操作。</li></ul><p>各运算符的功能如下：</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">示例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center"><code>&amp;</code></td><td align="center">与</td><td align="center"><code>false &amp; true</code></td><td align="center">false</td></tr><tr><td align="center"><code>|</code></td><td align="center">或</td><td align="center"><code>false | true</code></td><td align="center">true</td></tr><tr><td align="center"><code>^</code></td><td align="center">异或</td><td align="center"><code>true ^ false</code></td><td align="center">true</td></tr><tr><td align="center"><code>!</code></td><td align="center">非</td><td align="center"><code>!true</code></td><td align="center">false</td></tr><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">短路与</td><td align="center"><code>flase &amp;&amp; true</code></td><td align="center">false</td></tr><tr><td align="center"><code>||</code></td><td align="center">短路或</td><td align="center"><code>false || true</code></td><td align="center">true</td></tr></tbody></table><h3 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h3><p><strong>在 Java 中，如何跳出多重循环？</strong><br>在最外层循环前加一个标记如outfor，然后用break outfor;可以跳出多重循环。例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBreak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outfor: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span> outfor;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">j = 0</span><br><span class="line">j = 1</span><br><span class="line">j = 2</span><br><span class="line">j = 3</span><br><span class="line">j = 4</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>Java 的基本数据类型有哪些，各占几个字节？</strong></p><ul><li>数据类型：byte short int long float double boolean char</li><li>占用字节数：12484812（byte对应1，short对应2，以此类推）</li></ul><p><strong><code>short s1 = 1; s1 = s1 + 1;</code> 与 <code>short s1 = 1; s1 += 1;</code></strong></p><ul><li>前者不正确，后者正确。</li><li>对于 <code>short s1 = 1; s1 = s1 + 1;</code> 由于 1 是 int 类型，因此 <code>s1+1</code> 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。</li><li>而 <code>short s1 = 1; s1 += 1;</code> 可以正确编译，因为 <code>s1+= 1;</code> 相当于 <code>s1 = (short)(s1 + 1);</code> 其中有隐含的强制类型转换。</li></ul><p><strong>int 和 Integer 有什么区别？</strong><br>java 是一个完全面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。<br>java 为每个原始类型提供了包装类型：</p><ul><li>基本数据类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><p><strong>基本数据类型与 String 之间的转换</strong></p><ul><li>字符串如何转基本数据类型：调用基本数据类型对应的包装类中的方法 <code>parseXXX(String)</code> 或 <code>valueOf(String)</code> 即可返回相应基本类型。</li><li>基本数据类型如何转字符串：一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf() 方法返回相应字符串。</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>普通类和抽象类有哪些区别？</strong></p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><p><strong>抽象类必须要有抽象方法吗？</strong></p><ul><li>不需要，抽象类不一定非要有抽象方法。</li></ul><p><strong>抽象类能使用 final 修饰吗？</strong></p><ul><li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾</li></ul><p><strong>接口和抽象类有什么区别？</strong></p><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p><strong>Files的常用方法都有哪些？</strong></p><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射主要是指在程序运行期间可以访问、检测和修改它本身状态或行为的一种能力</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul><p>获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类</p><ul><li>通过 <code>getClass()</code> 方法</li><li>通过 <code>Class.forName()</code> 方法</li><li>使用 <code>类.class</code></li><li>通过类加载器实现，<code>getClassLoader()</code></li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p><p>什么情况下需要序列化：</p><ul><li>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>b）当你想用套接字在网络上传送对象的时候；</li><li>c）当你想通过RMI传输对象的时候；</li></ul><h3 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h3><p>有两种方式：</p><ul><li>1). 实现Cloneable接口并重写Object类中的clone()方法；</li><li>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li><li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li></ul><h3 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h3><ul><li>接口的默认方法只需要使用 default 关键字即可，这个特征又叫做 <strong>扩展方法</strong></li><li>Lambda 表达式</li><li>使用 <code>::</code> 双冒号关键字来传递方法(静态方法和非静态方法)</li><li>Functional 接口 函数式接口 是指仅仅只包含一个抽象方法的接口，每一个该类型的 Lambda 表达式都会被匹配到这个抽象方法。你只需要给你的接口添加 @FunctionalInterface 注解</li><li>Function 接口<ul><li>Function 有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法</li><li>compose 方法表示在某个方法之前执行</li><li>andThen 方法表示在某个方法之后执行</li><li>注意：compose 和 andThen 方法调用之后都会把对象自己本身返回，这可以 方便链式编程</li></ul></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>谈谈你对面向对象的理解</strong><br>所谓对象就是由一组数据结构和处理它们的方法组成的，重点“数据”包括对象的特性、状态等的静态信息；“方法” 也就是行为，包括该对象的对数据的操作、功能等能动信息。把相同行为的对象归纳为类，类是一个抽象的概念，对象是类的具体。简单点说：对象就是类的实例。例如：小品演员就是一个类，赵本山就是一个对象。</p><p>面向对象的目的：解决软件系统的可扩展性，可维护性和可重用性。</p><p><strong>什么叫对象？什么叫类？什么是面向对象（OOP）？</strong></p><ul><li>类的概念：类是具有相同属性和行为的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和服务说明两个主要部分。</li><li>对象的概念：对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成的。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><strong>面向对象包括哪些特性，如何理解的？</strong></p><ul><li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</li><li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</li><li>多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A系统访问B系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包类</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">protected</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✗</td></tr><tr><td align="center">缺省</td><td align="center">✓</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td></tr><tr><td align="center">private</td><td align="center">✓</td><td align="center">✗</td><td align="center">✗</td><td align="center">✗</td></tr></tbody></table><h3 id="多态机制"><a href="#多态机制" class="headerlink" title="多态机制"></a>多态机制</h3><p><strong>Java 中多态的机制是什么？</strong><br>Java中的多态靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p><p><strong>谈谈你对多态的理解</strong><br>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源代码，就可以让引用变量绑定到各种不同的对象上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>谈谈你对 Java 异常机制的理解</strong></p><ul><li>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception。<ul><li>Error 表示应用程序本身无法克服和恢复的一种严重问题。</li><li>Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常。<ul><li>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组下标越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）。</li><li>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</li></ul></li></ul></li><li>Java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统异常可以处理也可以不处理，所以编译器不强制用 try..catch 处理或用 throws 声明，所以系统异常也称为 unchecked 异常。</li></ul><h3 id="异常种类"><a href="#异常种类" class="headerlink" title="异常种类"></a>异常种类</h3><p>按照异常需要处理的时机分为编译时异常(也叫受控异常)也叫 CheckedException 和运行时异常(也叫非受控异常)也叫 UnCheckedException。Java 认为 Checked 异常都是可以被处理的异常，所以Java 程序必须显式处理 Checked 异常。如果程序没有处理 Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。对 Checked 异常处理方法有两种：</p><ul><li>第一种：当前方法知道如何处理该异常，则用try…catch块来处理该异常。</li><li>第二种：当前方法不知道如何处理，则在定义该方法时声明抛出该异常。</li></ul><p>运行时异常只有当代码在运行时才发行的异常，编译的时候不需要 try…catch。如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p><h3 id="Error、Exception"><a href="#Error、Exception" class="headerlink" title="Error、Exception"></a>Error、Exception</h3><p>Error 类和 Exception 类的父类都是 Throwable 类，他们的区别如下：</p><ul><li>Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。</li><li>Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li><li>Exception 类又分为未检查异常（UnCheckedException）和受检查的异常(CheckedException)。运行时异常 ArithmeticException，IllegalArgumentException 编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。而受检查的异常，要么用 try…catch 捕获，要么用 throws 字句声明抛出，交给它的父类处理，否则编译不会通过。</li></ul><h3 id="throw、throws"><a href="#throw、throws" class="headerlink" title="throw、throws"></a>throw、throws</h3><ul><li>throw：throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。</li><li>throws：throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这种异常。</li></ul><h3 id="常见的异常类"><a href="#常见的异常类" class="headerlink" title="常见的异常类"></a>常见的异常类</h3><ul><li>NullPointerException：空指针异常，调用了未经初始化的对象或者是不存在的对象。</li><li>ClassNotFoundException：指定的类找不到，类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。</li><li>IndexOutOfBoundsException：数组角标越界异常，指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li>IllegalArgumentException：方法传递参数错误，向方法传递了一个不合法或不正确的参数。</li><li>ClassCastException：数据类型转换异常，当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li>NoClassDefFoundException：未找到类定义错误。</li><li>InstantiationException：实例化异常。</li><li>NoSuchMethodException：方法不存在异常。</li><li>SQLException：SQL 异常，常见于操作数据库时的 SQL 语句错误。</li><li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li><li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li><li>IOException：当发生某种I&#x2F;O异常时，抛出此异常。此类是失败或中断的I&#x2F;O操作生成的异常的通用类。</li><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li><li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li><li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li><li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li><li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li><li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li><li>RuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li></ul><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><strong><code>Math.round(11.5)</code> 等于多少，<code>Math.round(-11.5)</code> 又等于多少？</strong></p><ul><li><code>Math.round(11.5)</code> 的返回值是12</li><li><code>Math.round(-11.5)</code> 的返回值是-11</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 常用方法：</p><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><p><strong>如何将字符串反转？</strong></p><ul><li>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</li></ul><p><strong>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</strong></p><ul><li>不一样，因为内存的分配方式不一样。<code>String str=&quot;i&quot;</code> 的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</li></ul><p><strong>String 类可以被继承吗？</strong></p><ul><li>String类在声明时使用final关键字修饰，被final关键字修饰的类无法被继承。</li></ul><p><strong>为什么 String 会被定义为 final 的呢？</strong></p><ul><li>因为只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么 String interning 将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</li><li>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</li><li>因为字符串是不可变的，所以在它创建的时候 HashCode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 Map 中的键，字符串的处理速度要快过其它的键对象。这就是 HashMap 中的键往往都使用字符串。</li></ul><p><strong>String 、StringBuilder 、StringBuffer 的区别？</strong><br>Java 平台提供了两种类型的字符串：String 和 StringBuffer&#x2F;StringBuilder，它们都可以储存和操作字符串，区别如下：</p><ul><li>String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</li><li>StringBuffer&#x2F;StringBuilder 表示的字符串对象可以直接进行修改。</li><li>StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被 synchronized 修饰，因此它的效率理论上也比 StringBuffer 要高。</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><strong>Java 中有几种类型的流？</strong></p><ul><li>按照流的方向：输入流（inputStream）和输出流（outputStream）</li><li>按照处理数据的单位： 字节流和字符流。字节流继承于 InputStream 和 OutputStream， 字符流继承于InputStreamReader 和 OutputStreamWriter 。</li></ul><h3 id="流之间的转换"><a href="#流之间的转换" class="headerlink" title="流之间的转换"></a>流之间的转换</h3><p><strong>字节流如何转换为字符流？</strong></p><ul><li>字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。</li><li>字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。</li></ul><h3 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h3><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><p>Java 中各类集合如下：</p><h3 id="Collection-和-Collections"><a href="#Collection-和-Collections" class="headerlink" title="Collection 和 Collections"></a>Collection 和 Collections</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="List、Set、Map"><a href="#List、Set、Map" class="headerlink" title="List、Set、Map"></a>List、Set、Map</h3><table><thead><tr><th align="center">区别</th><th align="center">List</th><th align="center">Set</th><th align="center">Map</th></tr></thead><tbody><tr><td align="center">继承接口</td><td align="center">Collection</td><td align="center">Collection</td><td align="center"></td></tr><tr><td align="center">常见实现类</td><td align="center">ArrayList、LinkedList、Vector</td><td align="center">HashSet、LinkedHashSet、TreeSet</td><td align="center">HashMap、HashTable</td></tr><tr><td align="center">常见方法</td><td align="center">add()、remove()、clear()、get()、contains()、size()</td><td align="center">add()、remove()、clear()、contains()、size()</td><td align="center">put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()</td></tr><tr><td align="center">元素</td><td align="center">可重复</td><td align="center">不可重复</td><td align="center">不可重复（key）</td></tr><tr><td align="center">顺序</td><td align="center">有序</td><td align="center">无序</td><td align="center">无序</td></tr></tbody></table><p><strong>List 和 Set 的区别：</strong></p><ul><li>List, Set 都是继承自 Collection 接口</li><li>List 特点：元素有放入顺序，元素可重复。Set 特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在 set 中的位置是有该元素的 HashCode 决定的，其位置其实是固定的）</li><li>List 接口有三个实现类：LinkedList，ArrayList，Vector。Set 接口有两个实现类：HashSet(底层由 HashMap 实现)，LinkedHashSet</li></ul><p><strong>List 和 Map 的区别：</strong></p><ul><li>List 特点：元素有放入顺序，元素可重复;</li><li>Map 特点：元素按键值对存储，无放入顺序 ;</li><li>List 接口有三个实现类：LinkedList，ArrayList，Vector;</li><li>LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢;</li><li>Map 接口有三个实现类：HashMap，HashTable，LinkedHashMap</li><li>Map 相当于和 Collection 一个级别的；Map 集合存储键值对，且要求保持键的唯一性；</li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>ArrayList 和 LinkedList 的区别：</strong></p><ul><li>因为 Array 是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array 获取数据的时间复杂度是 O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</li><li>相对于 ArrayList，LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 O(n)，而 LinkedList 中插入或删除的时间复杂度仅为 O(1)。ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。</li><li>类似于插入数据，删除数据时，LinkedList 也优于 ArrayList。</li><li>LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置。</li><li>你的应用不会随机访问数据。因为如果你需要 LinkedList 中的第 n 个元素的时候，你需要从第一个元素顺序数到第 n 个数据，然后读取数据。</li><li>你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比 ArrayList 要快。</li></ul><p><strong>ArrayList 和 Vector 的区别：</strong></p><ul><li>同步性：Vector 是线程安全的，也就是说是同步的 ，而 ArrayList 是线程不安全的，不是同步的。</li><li>数据增长：当需要增长时，Vector 默认增长为原来一倍 ，而 ArrayList 却是原来的 50% ，这样 ArrayList 就有利于节约内存空间。</li></ul><p>说明：如果涉及到堆栈，队列等操作，应该考虑用 Vector，如果需要快速随机访问元素，应该使用 ArrayList</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>HashMap 和 HashTable 的区别：</strong></p><ul><li>HashMap 去掉了 HashTable 的 contains方法，但是加上了 containsValue() 和 containsKey() 方法。</li><li>HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。</li><li>HashMap 允许空键值，而 HashTable 不允许。</li></ul><p><strong>HashMap 和 TreeMap 的区别</strong></p><ul><li>对于在 Map 中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</li></ul><p><strong>HashMap 和 HashSet 的区别：</strong></p><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">HashMap 实现了 Map 接口</td><td align="center">HashSet 实现了 Set 接口</td></tr><tr><td align="center">HashMap 储存键值对</td><td align="center">HashSet 仅仅存储对象</td></tr><tr><td align="center">使用 put() 方法将元素放入 map 中</td><td align="center">使用 add() 方法将元素放入 set 中</td></tr><tr><td align="center">HashMap 中使用键对象来计算 hashcode 值</td><td align="center">HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals() 方法用来判断对象的相等性，如果两个对象不同的话，那么返回 false</td></tr><tr><td align="center">HashMap 比较快，因为是使用唯一的键来获取对象</td><td align="center">HashSet 较 HashMap 来说比较慢</td></tr></tbody></table><h3 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p><p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><h3 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h3><ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放于HashMap的key上</li><li>HashMap的value统一为PRESENT</li></ul><h3 id="数组和-List-转换"><a href="#数组和-List-转换" class="headerlink" title="数组和 List 转换"></a>数组和 List 转换</h3><ul><li>List 转换成为数组：调用 ArrayList 的 toArray 方法。</li><li>数组转换成为 List：调用 Arrays 的 asList 方法。</li></ul><h3 id="Array-和-ArrayList"><a href="#Array-和-ArrayList" class="headerlink" title="Array 和 ArrayList"></a>Array 和 ArrayList</h3><ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小是固定的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><ul><li>Vector：就比 arraylist 多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在 web 应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>Stack：堆栈类，先进后出。</li><li>Hashtable：就比 Hashmap 多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><p>Collections 工具类提供了相关的 API，可以将不安全的集合是转换成线程安全的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedCollection(c);</span><br><span class="line">Collections.synchronizedList(list);</span><br><span class="line">Collections.synchronizedMap(m);</span><br><span class="line">Collections.synchronizedSet(s);</span><br></pre></td></tr></table></figure><h3 id="Map-中的-null"><a href="#Map-中的-null" class="headerlink" title="Map 中的 null"></a>Map 中的 null</h3><p>HashMap 对象的 key、value 值均可为 null。Hahtable 对象的 key、value 值均不可为 null。且两者的的 key 值均不能重复，若添加 key 相同的键值对，后面的 value 会自动覆盖前面的 value，但不会报错。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>迭代器(Iterator)是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><p><strong>Iterator 怎么使用？有什么特点？</strong><br>Java中的Iterator功能比较简单，并且只能单向移动：</p><ul><li>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li><li>(2) 使用next()获得序列中的下一个元素。</li><li>(3) 使用hasNext()检查序列中是否还有元素。</li><li>(4) 使用remove()将迭代器新返回的元素删除。</li></ul><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><p><strong>Iterator 和 ListIterator 有什么区别？</strong></p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul><li><strong>进程：</strong> 程序开始运行后，加载到内存的内容就是进程（资源分配的基本单位），一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。</li><li><strong>线程</strong>：线程是程序执行的基本单位，是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</li></ul><h3 id="程序运行过程"><a href="#程序运行过程" class="headerlink" title="程序运行过程"></a>程序运行过程</h3><p>程序是由一个一个指令组成的，程序运行的过程就是 CPU 读指令，PC（程序计数器）存储指令地址，然后读数据，将数据存储在 Register 中，CPU对数据进行计算与回写，再下一条指令</p><p><strong>线程切换</strong>：CPU 保存原线程执行进度，加载新线程的一个过程</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>继承 Thread 类创建线程类</strong></p><ul><li>定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。</li><li>创建 Thread 子类的实例，即创建了线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ul><p><strong>通过 Runnable 接口创建线程类</strong></p><ul><li>定义 runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ul><p><strong>通过 Callable 和 Future 创建线程</strong></p><ul><li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ul><p><strong>各种方法的优势与劣势：</strong></p><ul><li>Rannable、Callable<ul><li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li><li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</li></ul></li><li>Thread<ul><li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li><li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li></ul></li></ul><h3 id="runnable-和-callable"><a href="#runnable-和-callable" class="headerlink" title="runnable 和 callable"></a>runnable 和 callable</h3><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程通常都有五种状态，<strong>创建、就绪、运行、阻塞和死亡</strong></p><ul><li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li><li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li><li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li><li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li><li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</li></ul><p>　　</p><h3 id="sleep-wait-yield-join"><a href="#sleep-wait-yield-join" class="headerlink" title="sleep(),wait(),yield(),join()"></a>sleep(),wait(),yield(),join()</h3><ul><li>sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</li><li>wait() 是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</li><li>yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，另外 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep() 方法不同。</li><li>join() 方法会使当前线程等待调用 join() 的线程结束后才能继续执行</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify(),notifyAll()"></a>notify(),notifyAll()</h3><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul><h3 id="run-start"><a href="#run-start" class="headerlink" title="run(),start()"></a>run(),start()</h3><ul><li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</li><li>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li><li>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>什么是线程池，如何使用？</strong><br>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。在 JDK 的 <code>java.util.concurrent.Executors</code> 中提供了生成多种线程池的静态方法。调用他们的 execute 方法即可使用。</p><p><strong>创建线程池的方式</strong></p><ul><li>①. newFixedThreadPool(int nThreads)<br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li><li>②. newCachedThreadPool()<br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</li><li>③. newSingleThreadExecutor()<br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</li><li>④. newScheduledThreadPool(int corePoolSize)<br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</li></ul><p>线程池有5种状态：<strong>Running、ShutDown、Stop、Tidying、Terminated</strong>。</p><p>线程池各个状态切换框架图：</p><p><strong>请叙述一下您对线程池的理解？</strong><br>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p><ul><li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p><strong>线程池的启动策略？</strong></p><ul><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个任务时，线程池会做如下判断：<ul><li>（1）如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</li><li>（2）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li><li>（3）如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建线程运行这个任务；</li><li>（4）如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。</li><li>（5）当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>（6）当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</li></ul></li></ul><h3 id="submit-execute"><a href="#submit-execute" class="headerlink" title="submit(),execute()"></a>submit(),execute()</h3><ul><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全在三个方面体现：</p><ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li></ul><p>线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。</p><p>在 Java 多线程编程当中，提供了多种实现 Java 线程安全的方式：</p><ul><li>最简单的方式，使用 Synchronization 关键字</li><li>使用 java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger</li><li>使用 java.util.concurrent.locks 包中的锁</li><li>使用线程安全的集合 ConcurrentHashMap</li><li>使用 volatile 关键字，保证变量可见性（直接从内存读，而不是从线程 cache 读）</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>在 Java 中，锁共有 4 种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p><p>锁升级的图示过程：</p><ul><li>当只有一个线程来争夺资源时，该资源是一个偏向锁，当有其他线程来争夺时，会从偏向锁升级为自旋锁</li><li>因此偏向锁就是 synchronized 在只有一个线程时对锁的一个优化</li><li>轻量级锁中，如何线程等待时间过长，会再次进行升级为重量级锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><h3 id="怎么防止死锁"><a href="#怎么防止死锁" class="headerlink" title="怎么防止死锁"></a>怎么防止死锁</h3><p>死锁的四个必要条件：</p><ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p><p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p><p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>ThreadLocal：</strong></p><ul><li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。</li><li>Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。</li><li>但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。</li><li>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li></ul><p><strong>ThreadLocal 实现原理：</strong></p><ul><li>对象在使用 set 方法的时候，会将 ThreadLocal 对象本身和值设置到当前线程的 threadLocals 对象中去，</li><li>由于每个线程的 threadLocals（ThreadLocalMap） 对象都不一样，因此ThreadLocal 对象 set 的值并不是线程共享的</li><li>threadLocals 中的 key 就是一个 弱引用，指向 ThreadLocal 对象</li><li>为什么 threadLocals 中的 key 不能是强引用：</li><li>因为如果我们不需要 ThreadLocal 对象的时候，这时候线程中的 threadLocals key 对 TL 是一个强引用，不会被GC清理，就会造成内存泄漏</li><li>但是 threadLocals 中的 value 是一个强引用，还是会有内存泄漏，因此在使用 ThreadLocal 时，如果该对象确定不用了，要记得 remove</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><strong>两大作用：</strong></p><ul><li>① 线程间可见：使用 volatile 修饰的内存，只要其在某个线程中发生改变，其他线程中立马可见</li><li>② 禁止指令重排序（使用内存屏障实现）：用 volatile 修饰的内存，在其上面执行的指令，不可以乱序</li></ul><p><strong>DCL：Double Check Lock 双重锁检查</strong></p><ul><li>锁必须要加 volatile，这里就是使用 volatile 的禁止指令重排序的功能，因为创建对象的时候</li><li>构造器和建立关联的指令是可能会重排的，也就是说先建立了关联但是没有构造，</li><li>此时对象引用的已经不为空了，但是实际内容是空，这时候来了一个线程进行判断就会将其当成一个不为空的对象</li></ul><p><strong>对象创建的过程（半初始化）：</strong></p><ol><li>先申请一块内存空间（new 指令）</li><li>调用构造器方法（invokespecial 指令）</li><li>建立关联（astore 指令）</li></ol><p><strong>volatile 实现原理：</strong></p><ul><li>在 JVM 底层 volatile 是采用“内存屏障”来实现的</li><li>缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个 CPU 在写数据时，如果发现操作的变量是共享变量，则会通知其他 CPU 告知该变量的缓存行是无效的，因此其他 CPU 在读取该变量时，发现其无效会重新从主存中加载数据</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><p>使用这个关键字一定会有一把锁，如果是 synchronized() 方法，锁就是中括号是的对象，如果是修饰的方法，那锁就是 this，如果修改的静态方法，那锁就是当前的 class</p><p><strong>不持有锁的线程怎么办？</strong></p><ul><li>① 忙等待（自旋锁，轻量级锁）</li><li>② 进队列等待（重量级锁）</li></ul><p><strong>注意</strong>：不同的场景用不同的锁，并不是说自旋锁效率一定比重量级锁高</p><blockquote><p>synchronized 关键字最早的时候用的是重量级锁，在 1.5 的时候，增加了一个 JUC（java.util.concurrent） 包用于处理并发</p></blockquote><blockquote><p>JUC 中的 Atomic 相关类就是一个 轻量级锁（自旋锁，实现方法：CAS，CompareAndSwap，一个线程对一个值进行修改，会先读取这个值，修改后和原值比较是否是期望的那个值，如果是就替换，不是就再来操作一次）</p></blockquote><blockquote><p>CAS 的 ABA 问题：CAS 的过程中修改了值后，发现为期望值，但是这个期望值可能是修改了多次后又改回来的值（也就是说这个值并不是期望值），解决这个问题通常用版本号来解决</p></blockquote><blockquote><p>CAS 修改值时候的原子性问题：CAS 在最底层是由 cmpxchg（也是cas的方式修改值） 的汇编指令来操作的，在其前面加一条 lock（锁总线） 汇编指令就可保证其原子性</p></blockquote><p><strong>synchronized 和 volatile 的区别</strong></p><ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul><p><strong>synchronized 和 Lock 的区别</strong></p><ul><li>首先 synchronized 是 java 内置关键字，在 jvm 层面，Lock 是个 java 类；</li><li>synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用 synchronized 关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized 的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul><h3 id="atomic-的原理？"><a href="#atomic-的原理？" class="headerlink" title="atomic 的原理？"></a>atomic 的原理？</h3><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h3><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><p>java 程序在运行的过程中会先由JVM的 <strong>类装载子系统</strong> 把 class 文件加载到 <strong>运行时数据区（内存模型）</strong><br>然后由 JVM 中的 <strong>字节码执行引擎</strong> 来运行 java 程序</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><ul><li>堆</li><li>虚拟机（栈）</li><li>方法区</li><li>程序计数器</li><li>本地方法栈</li></ul><p><strong>其中</strong>：</p><ul><li>栈：当我们运行一个线程时，JVM 会在栈中分配一个空间给该线程<br>线程中的一些方法则在空间中以 <strong>栈帧</strong> 的方式再分配空间（如执行某个方法就分配一个栈帧压入线程栈中）<br>栈帧中同样会分配不同的空间，一般来说，会有如下空间：<ul><li>局部变量表、操作数栈（存储临时的操作数）、动态链接、方法出口</li></ul></li><li>程序计数器：每个线程都会分配一个空间用于记录线程动态<br>当CPU切换线程时可方便找到这个 Java 线程的运行时刻</li><li>堆：通常 new 出来的对象是保存在堆中的</li><li>方法区（元空间）：通常用来存放常量、静态变量、类信息</li><li>本地方法栈：通常是 native 方法，也就是以 C 语言执行的方法，但是现在基本不用本地方法了</li></ul><h3 id="堆栈区别"><a href="#堆栈区别" class="headerlink" title="堆栈区别"></a>堆栈区别</h3><ul><li>栈内存存储的是局部变量而堆内存存储的是实体；</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><strong>类加载分为以下 5 个步骤：</strong></p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><p><strong>类初始化过程：</strong></p><ul><li>① 一个类要创建实例需要先加载并初始化该类（main 方法所在的类需要先加载和初始化）</li><li>② 一个子类要初始化需要先初始化父类</li><li>③ 一个类初始化就是执行 <code>&lt;clinit&gt;()</code> 方法（可在字节码文件中看到）<br><code>&lt;clinit&gt;()</code> 方法由 静态类变量显示赋值 代码和 静态代码块 组成<br>类变量显示赋值 代码和 静态代码块 代码从上到下顺序执行<br><code>&lt;clinit&gt;()</code> 方法只执行一次</li></ul><p><strong>实例初始化过程：</strong><br>实例初始化就是执行 <code>&lt;init&gt;()</code> 方法</p><ul><li><code>&lt;init&gt;()</code> 方法可能重载有多个，有几个构造器就有几个 <code>&lt;init&gt;()</code> 方法</li><li><code>&lt;init&gt;()</code> 方法由 <strong>非静态实例变量显示赋值</strong> 代码和 <strong>非静态代码块</strong>、对应构造器代码组成</li><li>非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，对应构造器代码最后执行</li><li>注意：每 new 一次对象，就会调用对应构造器，执行对应的 <code>&lt;init&gt;()</code> 方法</li><li><code>&lt;init&gt;()</code> 方法首行一定是 super() 方法，无论其有没有书写</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>从 Java 虚拟机的角度来说，只存在两种不同的类加载器：一种是 <strong>启动类加载器（Bootstrap ClassLoader）</strong>，这个类加载器使用 C++ 语言实现（HotSpot 虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有 Java 语言实现，独立于虚拟机外部，并且全部继承自 java.lang.ClassLoader。</p><p>从开发者的角度，类加载器可以细分为：</p><ul><li>启动（Bootstrap）类加载器：负责将 Java_Home&#x2F;lib 下面的类库加载到内存中（比如 rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li><li>标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader） 实现的。它负责将 Java_Home &#x2F;lib&#x2F;ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li><li>应用程序（Application）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader） 实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统（System）加载器。</li><li>自定义加载器，CustomClassLoader，用户自定义的类加载器,可加载指定路径的 class 文件</li></ul><p>这些加载器的层次关系被称为类加载器的 <strong>双亲委派模型</strong>。该模型要求 <strong>除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。</strong></p><p>如图所示：</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>当某个类加载器需要加载某个 <code>.class</code> 文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</p><p><strong>作用：</strong></p><ol><li>防止重复加载同一个 <code>.class</code> 。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</li><li>保证核心 <code>.class</code> 不能被篡改。通过委托方式，不会去篡改核心 <code>.class</code> ，即使篡改也不会去加载，即使加载也不会是同一个 <code>.class</code> 对象了。不同的加载器加载同一个 <code>.class</code> 也不是同一个Class对象。这样保证了Class执行安全。</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Java 中一共四种引用：</p><ul><li>强引用<ul><li>通常用的 new 就是强引用</li></ul></li><li>软引用<ul><li>软引用借助 SoftReference 来实现，当堆内存够用的情况下，软引用不会被GC清理</li><li>当堆内存不够的情况下，软引用会被清理，而不关心它是否有引用，软引用通常用于缓存</li></ul></li><li>弱引用<ul><li>弱引用借助 WeekReference 来实现，只要GC来清理垃圾，弱引用就会被清理。ThreadLocal 中的 Entry 就是一个弱引用</li></ul></li><li>虚引用<ul><li>虚引用借助 PhantomReference 来实现，通常开发人员不常用，写类库的人用的较多，如 ByteBuffer（零拷贝） 管理堆外内存就使用了 虚引用</li></ul></li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>引用计数算法（废弃）</li><li>根搜索算法（使用）</li><li>Mark-sweep （标记清除）：将垃圾标记，然后清除，缺点：内存碎片化</li><li>Copying （拷贝）：将不是垃圾的对象拷贝到其他的空间，然后清除之前的所有空间，缺点：浪费空间</li><li>Mark-Compact （标记整理）：一边对垃圾进行标记，一边整理非垃圾，缺点：效率低下</li><li>分代收集算法</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>JVM 诞生以来一共有十种垃圾回收器</p><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>Parallel 收集器是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>ParNew：多线程收集器，与 Parallel 类似，ParNew 是专门用来配合 CMS 的</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B&#x2F;S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li><li>ZGC：分区模型</li><li>Shenandoah：分区模型</li><li></li></ul><h3 id="找垃圾的方式"><a href="#找垃圾的方式" class="headerlink" title="找垃圾的方式"></a>找垃圾的方式</h3><p><strong>垃圾对象</strong>：当一个对象没有引用指向它时，它就是一个垃圾</p><p>一般有两种方法来判断：</p><ul><li>Reference Count（引用计数）：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>Root Searching（JVM 默认）：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS(concurrent mark sweep) 回收垃圾的过程有 6 个阶段，通常只考虑其中4个阶段：</p><ul><li>初始标记：STW，标记 GC root</li><li>并发标记：与正在运行的进程并发，从 GC root 开始往下进行标记，其中会产生浮动垃圾，但是没关系，下一次可以顺利清理；主要是会产生 <strong>错标</strong> 问题</li><li>重新标记：STW 修正错标（三色标记算法）</li><li>并发清理：与正在运行的进程并发，进行垃圾的清理</li></ul><h3 id="分代-GC-工作方式"><a href="#分代-GC-工作方式" class="headerlink" title="分代 GC 工作方式"></a>分代 GC 工作方式</h3><p>分代垃圾回收器通常会将堆分成两个部分：年轻代（1&#x2F;3）、老年代（2&#x2F;3）。其中年轻代分为两个区，Eden 区（8&#x2F;10）和 Survivor 的两个空间（1&#x2F;10）。</p><p><strong>工作方式：</strong></p><ul><li>我们创建的对象通常会放到 Eden 区中，当 Eden 区放满了之后，会进行一次 Minor GC&#x2F;YGC 使用 <strong>复制算法（Copying）</strong> 将非垃圾复制到 Survivor 区中的其中一个空间，且对象的分代年龄加一；</li><li>Eden 区再次满了之后，又会进行一次 Minor GC&#x2F;YGC，此时会将 Eden 区和 Survivor 区的所有非垃圾复制到 Survivor 区的另一个空间并清理这两个空间，存活的对象分代年龄会加一；</li><li>GC时如果分代年龄为 15（默认值）的对象会进入老年代中，当老年代空间满了之后，会进行一次 Full GC&#x2F;Major GC 清理老年代空间，如果无法清理，则会有内存溢出的现象</li></ul><p><strong>对象动态年龄判断</strong>：</p><ul><li>当进行 Minor GC 时，如果存放的对象内存超过 Survivor 中的一个空间的 50% 时，会将其直接放入老年代中</li></ul><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p><strong>STW（stop-the-world）</strong>，每做一次 GC 会使除GC线程的其他所有线程阻塞。<br>JVM 调优的目的就是减少 STW 的次数（主要是减少 Full GC 的次数，因为 Full GC 会检索整个老年代空间从而占用大量的时间）</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p><strong>解释一下什么是 Servlet， 说一说 Servlet 的生命周期</strong></p><p>Servlet 是一种服务器端的 Java 应用程序，具有独立于平台和协议的特性，可以生成动态的 Web 页面。 它担当客户请求（Web 浏览器或其他 HTTP 客户程序）与服务器响应（HTTP 服务器上的数据库或应用程序）的中间层。Servlet是位于 Web 服务器内部的服务器端的 Java 应用程序，与传统的从命令行启动的 Java 应用程序不同，Servlet 由 Web 服务器进行加载，该 Web 服务器必须包含支持 Servlet 的 Java 虚拟机。</p><p>Servlet 生命周期可以分成四个阶段：加载和实例化、初始化、服务、销毁。当客户第一次请求时，首先判断是否存在 Servlet 对象，若不存在，则由 Web 容器创建对象，而后调用 init()方法对其初始化，此初始化方法在整个 Servlet 生命周期中只调用一次。完成 Servlet 对象的创建和实例化之后，Web 容器会调用 Servlet 对象的 service()方法来处理请求。当 Web 容器关闭或者 Servlet 对象要从容器中被删除时，会自动调用 destory()方法。</p><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>JSP 本质上就是一个 Servlet，它是 Servlet 的一种特殊形式（由 SUN 公司推出），每个 JSP 页面都是个 Servlet 实例。</p><ul><li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</li><li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</li><li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li><li>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li></ul><p>JSP 的运行机制如下图所示：</p><p>JVM 只能识别 Java 类，并不能识别 jsp 代码！web 容器收到以 <code>.jsp</code> 为扩展名的 url 请求时，会将访问请求交给 tomcat 中 jsp 引擎处理，每个 jsp 页面第一次被访问时，jsp 引擎将 jsp 代码解释为一个 servlet 源程序，接着编译 servlet 源程序生成 <code>.class</code> 文件，再有 web 容器 servlet 引擎去装载执行 servlet 程序，实现页面交互。</p><h3 id="jsp-内置对象"><a href="#jsp-内置对象" class="headerlink" title="jsp 内置对象"></a>jsp 内置对象</h3><p>JSP 有 9 个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h3 id="jsp-的-4-种作用域"><a href="#jsp-的-4-种作用域" class="headerlink" title="jsp 的 4 种作用域"></a>jsp 的 4 种作用域</h3><p>JSP 中的四种作用域包括 page、request、session 和 application，具体来说：</p><ul><li>page代表与一个页面相关的对象和属性。</li><li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><strong>过滤器有哪些作用和用法？</strong></p><p>对于一个 web 应用程序来说，过滤器是处于 web 容器内的一个组件，它会过滤特定请求资源请求信息和响应信息。一个请求来到时，web 容器会判断是否有过滤器与该信息资源相关联，如果有则交给过滤器处理，然后再交给目标资源，响应的时候则以相反的顺序交给过滤器处理，最后再返回给用户浏览器。</p><p>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件等。</p><h3 id="MVC-设计思想"><a href="#MVC-设计思想" class="headerlink" title="MVC 设计思想"></a>MVC 设计思想</h3><p>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。 这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层：</p><ul><li>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</li><li>最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</li><li>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</li></ul><h3 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h3><ul><li>向 DriverManager 类注册驱动数据库驱动程序</li><li>调用 DriverManager.getConnection 方法， 通过 JDBC URL，用户名，密码取得数据库连接的 Connection 对象。</li><li>获取 Connection 后， 便可以通过 createStatement 创建 Statement 用以执行 SQL 语句。</li><li>有时候会得到查询结果，比如 select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。</li><li>关闭数据库语句，关闭数据库连接。</li></ul><h3 id="session-和-cookie"><a href="#session-和-cookie" class="headerlink" title="session 和 cookie"></a>session 和 cookie</h3><ul><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li><li>cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li><li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li></ul><p><strong>Cookie 和 Session 的不同点：</strong></p><ul><li>无论客户端做怎样的设置，Session 都能够正常工作。当客户端禁用 Cookie 时将无法使用 Cookie。</li><li>在存储的数据量方面：Session 能够存储任意的 java 对象，Cookie 只能存储 String 类型的对象。</li></ul><h3 id="session-的工作原理"><a href="#session-的工作原理" class="headerlink" title="session 的工作原理"></a>session 的工作原理</h3><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。</p><h3 id="如何避免-sql-注入"><a href="#如何避免-sql-注入" class="headerlink" title="如何避免 sql 注入"></a>如何避免 sql 注入</h3><ul><li>PreparedStatement（简单又有效的方法）</li><li>字符串过滤</li><li>JSP页面判断代码</li></ul><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS攻击又称CSS,全称Cross Site Script（跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。</p><p>XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><p>CSRF（Cross-site request forgery, <strong>跨站请求伪造</strong>）。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。</p><p>如何避免：</p><ul><li>验证 HTTP Referer 字段<br>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF<br>攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</li><li>使用验证码<br>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="http-响应码"><a href="#http-响应码" class="headerlink" title="http 响应码"></a>http 响应码</h3><ul><li>200 （成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容）服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li><li>300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>400 （错误请求）服务器不理解请求的语法。</li><li>401 （未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止）服务器拒绝请求。</li><li>404 （未找到）服务器找不到请求的网页。</li><li>405 （方法禁用）禁用请求中指定的方法。</li><li>406 （不接受）无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度）服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型）请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值）服务器未满足”期望”请求标头字段的要求。</li><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关）服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h3 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h3><ul><li>安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS&#x2F;SSL加密的HTTP协议</li><li>申请证书上，HTTPS需要使用ca申请证书</li><li>传输协议上, HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议</li><li>连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443</li></ul><h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p><strong>http 的长连接和短连接区别？</strong></p><ul><li>HTTP 协议有 HTTP&#x2F;1.0 版本和 HTTP&#x2F;1.1 版本。HTTP1.1 默认保持长连接（HTTP persistent connection，也翻译为持久连接），数据传输完成了保持 TCP 连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。</li><li>在 HTTP&#x2F;1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。从 HTTP&#x2F;1.1 起，默认使用的是长连接，用以保持连接特性。</li></ul><h3 id="forward-和-redirect"><a href="#forward-和-redirect" class="headerlink" title="forward 和 redirect"></a>forward 和 redirect</h3><p>Forward 和 Redirect 代表了两种请求转发方式：<strong>直接转发</strong>和<strong>间接转发</strong>。</p><ul><li>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li><li>间接转发方式（Redirect）实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</li></ul><h3 id="tcp-和-udp"><a href="#tcp-和-udp" class="headerlink" title="tcp 和 udp"></a>tcp 和 udp</h3><ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ul><h3 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h3><p>在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><ul><li>第一次握手：建立连接时，客户端发送 syn 包 (syn&#x3D;j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。</li><li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN(ack&#x3D;j+1)，同时自己也发送一个 SYN 包 (syn&#x3D;k)，即SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据</li></ul><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><ul><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ul><h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h2 id="Spring-x2F-Spring-MVC"><a href="#Spring-x2F-Spring-MVC" class="headerlink" title="Spring &#x2F; Spring MVC"></a>Spring &#x2F; Spring MVC</h2><h3 id="为什么要使用-spring"><a href="#为什么要使用-spring" class="headerlink" title="为什么要使用 spring"></a>为什么要使用 spring</h3><ul><li>目的：解决企业应用开发的复杂性</li><li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li><li>范围：任何Java应用</li></ul><h3 id="Spring-能干什么"><a href="#Spring-能干什么" class="headerlink" title="Spring 能干什么"></a>Spring 能干什么</h3><ul><li>Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。</li><li>Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可</li><li>Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。</li><li>Spring 面向切面编程能提供一种更好的方式来完成，一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。</li><li>Spring 能非常简单的帮我们管理数据库事务。</li><li>采用 Spring，我们只需获取连接，执行SQL，其他事物相关的都交给Spring来管理了。</li><li>Spring 还能与第三方数据库访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。</li><li>Spring 还能与第三方 Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套 SpringMVC 框架，来方便 web 层搭建。</li><li>Spring 能方便的与 JavaEE（如JavaMail、任务调度）整合，与更多技术整合（比如缓存框架）。</li></ul><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><strong>BeanFactory常用的实现类有哪些？</strong><br>Bean工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。常用的BeanFactory实现有DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等。XMLBeanFactory，最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中的定义加载beans。该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><p><strong>ApplicationContext 的实现类有哪些？</strong></p><ul><li>FileSystemXmlApplicationContext：此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><p><strong>BeanFactory 与 AppliacationContext 有什么区别？</strong></p><ul><li>BeanFactory：基础类型的IOC容器，提供完成的IOC服务支持。如果没有特殊指定，默认采用延迟初始化策略。相对来说，容器启动初期速度较快，所需资源有限。</li><li>ApplicationContext：ApplicationContext是在BeanFactory的基础上构建，是相对比较高级的容器实现，除了BeanFactory的所有支持外，ApplicationContext还提供了事件发布、国际化支持等功能。ApplicationContext管理的对象，在容器启动后默认全部初始化并且绑定完成。</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p><p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p><h3 id="spring-主要模块"><a href="#spring-主要模块" class="headerlink" title="spring 主要模块"></a>spring 主要模块</h3><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问&#x2F;集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>什么是 Spring 的依赖注入？</strong><br>平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。</p><p>Spring 通过DI（依赖注入）实现 IOC（控制反转），常用的注入方式主要有三种：</p><ul><li>构造方法注入</li><li>setter注入</li><li>基于注解的注入</li></ul><h3 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h3><ul><li>Bean 定义：在配置文件里面用 <code>&lt;bean&gt;&lt;/bean&gt;</code> 来进行定义。</li><li>Bean 初始化：有两种方式初始化：<ul><li>在配置文件中通过指定 init-method 属性来完成。</li><li>实现 org.springframwork.beans.factory.InitializingBean 接口。</li></ul></li><li>Bean 调用：有三种方式可以得到 Bean 实例，并进行调用</li><li>Bean 销毁：销毁有两种方式：<ul><li>使用配置文件指定的 destroy-method 属性。</li><li>实现 org.springframwork.bean.factory.DisposeableBean。</li></ul></li></ul><h3 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><ul><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li><li>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>基于 TransactionProxyFactoryBean 的声明式事务管理</li><li>基于 @Transactional 的声明式事务管理</li><li>基于 Aspectj AOP 配置事务</li></ul><h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><p><strong>事务的传播行为（传播属性）：</strong></p><ul><li>当事务方法被另一个事务方法去调用时，必须指定事务应该如何传播，是使用原来的事务还是开启一个新的事务</li></ul><p><strong>属性：</strong></p><ul><li>propagation：用来设置事务的传播行为（Spring 定义了 7 种传播行为，这里介绍常用的两种）<ul><li>REQUIRED：默认值，使用原来的事务</li><li>REQUIRED_NEW：将原来的事务挂起，开启一个新事务</li></ul></li><li>isolation：用来设置事务的隔离级别<ul><li>REPEATABLE_READ：可重复读，MySql 默认的隔离级别，可避免脏读与不可重复读的问题</li><li>READ_COMMITTED：读已提交， Oracle 默认的隔离级别，开发时通常使用的隔离级别，可解决脏读的问题</li><li>READ_UNCOMMITTED：读未提交，可以读取到未提交的数据，不能解决任何问题</li></ul></li></ul><h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><ul><li>脏读（一个事务读到了另一个事务回滚前的无效值）</li><li>不可重复读（一个事务重复读一个值时被另一个事务修改，造成多次读取的结果不一样）</li><li>幻读（一个事务重复读一组数据时，被另一个事务添加了数据，再次读取时发现多了数据，就像产生了幻觉一样）</li></ul><h3 id="Smvc-运行流程"><a href="#Smvc-运行流程" class="headerlink" title="Smvc 运行流程"></a>Smvc 运行流程</h3><ul><li>用户发送请求，由中央控制器（DispatcherServlet）收到请求，调用 HandlerMapping（处理器映射器）找到处理器</li><li>然后 DispatcherServlet 会将映射器的结果传给 HandlerAdapter （处理器适配器）来调用相应的 Controller（如果有拦截器会执行拦截器的 preHandler 方法）</li><li>Controller 将 ModelAndView 一步一步返回给 DispatcherServlet，然后中央 Servlet 调用 ViewResolver</li><li>（视图解析器）将 view （视图）返回给 中央 Servlet，中央 Servlet 再对 view 进行渲染（如果有拦截器，则执行拦截器的 postHandler 方法）</li><li>将渲染好的视图返回给用户</li></ul><h3 id="Smvc-有哪些组件"><a href="#Smvc-有哪些组件" class="headerlink" title="Smvc 有哪些组件"></a>Smvc 有哪些组件</h3><ul><li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li><li>Controller：具体处理请求的控制器</li><li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li><li>ModelAndView：服务层返回的数据和视图层的封装类</li><li>ViewResolver：视图解析器，解析具体的视图</li><li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li></ul><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><ul><li>解决 POST 乱码：在 web.xml 中配置一个过滤器 filter：CharacterEncodingFilter，将其 encoding 的值配置为 utf-8</li><li>解决 Get 乱码：在 Tomcat 的 server.xml 中的 Connector 标签中添加 URIEncoding&#x3D;”UTF-8” 的属性</li></ul><h3 id="拦截器、过滤器、监听器"><a href="#拦截器、过滤器、监听器" class="headerlink" title="拦截器、过滤器、监听器"></a>拦截器、过滤器、监听器</h3><ul><li>拦截器：是指通过统一拦截从浏览器发往服务器的请求来完成功能的增强。使用场景：解决请求的共性问题（乱码问题、权限验证问题）。</li><li>过滤器：Servlet 中的过滤器 Filter 是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登录、有没有权限访问该页面等等工作。它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。</li><li>监听器：现在来说说 Servlet 的监听器 Listener，其中有一个监听器是监听上下文的，它实现了javax.servlet.ServletContextListener接口，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化的内容、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。</li></ul><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Spring 常用注解：</p><ul><li><code>@Required</code>：该注解应用于设值方法。</li><li><code>@Autowired</code>：该注解应用于有值设值方法、非设值方法、构造方法和变量。</li><li><code>@Qualifier</code>：该注解和 <code>@Autowired</code> 搭配使用，用于消除特定 bean 自动装配的歧义。</li></ul><p>Spring MVC 常用注解：</p><ul><li><code>@RequestMapping</code> 用于请求url映射。</li><li><code>@RequestBody</code> 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</li><li><code>@ResponseBody</code> 注解实现将 controller 方法返回对象转化为 json 响应给客户。</li></ul><p><strong>注</strong>：注解装配在 spring 中默认是关闭的。所以需要在 spring 的核心配置文件中配置一下才能使用基于注解的装配模式。配置方式如下：<code>&lt;context:annotation-config/&gt;</code>；Spring MVC 需要 <code>&lt;mvc:annotation-driven&gt;</code> 来实现注解的开启</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中。当然反过来也是可以的，例如将数据库表当中的记录查询出来，然后映射为 Java 程序中的 Java 对象。</p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和 ${}的区别"></a>#{}和 ${}的区别</h3><ul><li>#{}是预编译处理，${}是字符串替换；</li><li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理${}时，就是把${}替换成变量的值；</li><li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>创建 SqlSessionFactory</li><li>通过 SqlSessionFactory 创建 SqlSession</li><li>通过 sqlsession 执行数据库操作</li><li>调用 session.commit() 提交事务</li><li>调用 session.close() 关闭会话</li></ol><h3 id="字段名与表名不同"><a href="#字段名与表名不同" class="headerlink" title="字段名与表名不同"></a>字段名与表名不同</h3><ol><li>在写 Sql 语句中的时候起别名，让别名和我们类中的属性名保持一致</li><li>在 MyBatis 的全局配置文件中开启驼峰命名规则（settings 标签中的 setting name&#x3D;mapUnderscoreToCameCase）</li><li>在 Mapper 映射文件中使用 ResultMap 来自定义映射规则（result 标签中的 colunm 对应数据库表，property 对应实体类）</li></ol><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt;</code></li></ul><h3 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h3><p>Mybatis有三种基本的执行器（Executor）：</p><ul><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h3 id="char-和-varchar"><a href="#char-和-varchar" class="headerlink" title="char 和 varchar"></a>char 和 varchar</h3><ul><li>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</li><li>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</li><li>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</li></ul><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h3 id="float-和-double"><a href="#float-和-double" class="headerlink" title="float 和 double"></a>float 和 double</h3><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul><h3 id="内连接、左连接、右连接"><a href="#内连接、左连接、右连接" class="headerlink" title="内连接、左连接、右连接"></a>内连接、左连接、右连接</h3><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引（Index）是帮助 MySQL 高效获取数据的 <strong>排好序的</strong> 数据结构</p><ul><li>优势：提高数据检索的效率，降低数据库的 IO 成本；通过索引对数据进行排序，降低数据排序成本，降低 CPU 消耗</li><li>劣势：虽然索引大大提高了查询速度，同时却会降低更新表的速度（写操作）；索引会额外占用磁盘空间</li></ul><p>索引的数据结构通常是：B+Tree，一个结点存储多个数据（MySQL通常限制为 16K），可以将树的高度控制在</p><p>一个比较小的范围中，千万级别的数据量也可以在很少的磁盘IO中读取到查找的内容，</p><p>同时，B+树的叶子结点对范围查找也是非常友好的</p><p><strong>InnoDB索引（聚集索引）：</strong></p><ul><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引：叶子结点包含了完整的数据记录</li><li>为什么 InnoDB表必须要有主键，并且推荐使用整型的自增主键？</li><li>因为InnoDB的主键索引是一个聚集索引，InnoDB在对表进行操作时候需要维护这个索引</li></ul><p><strong>联合索引的底层存储结构长什么样？</strong></p><ul><li>同样是一颗 B+Tree，只不过是字段的比较不再是比第一个了，而是从上往下</li><li>第一个字段相同时，比第二个字段，第一第二个字段都相同时，比第三个字段</li></ul><p><strong>MySQL什么时候适合建索引，什么时候不适合？</strong></p><ul><li>主键会自动建立唯一索引；</li><li>频繁作为查询条件的字段应该创建索引；</li><li>外键关系关联查询应该创建索引；</li><li>组合键应该创建索引；</li><li>排序字段或统计分组时应该创建索引；</li><li>表记录太少时不适合；经常增删改的表或字段<strong>不适合</strong>；</li><li>Where 里面用不到的字段不适合；过滤性不好的字段<strong>不适合</strong>；</li></ul><h3 id="事务隔离-1"><a href="#事务隔离-1" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation &#x3D; REPEATABLE-READ</p><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><ul><li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>其中</p><ul><li>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li>不可重复读 ：是指在一个事务内，多次读同一数据。</li><li>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li></ul><h3 id="常用引擎"><a href="#常用引擎" class="headerlink" title="常用引擎"></a>常用引擎</h3><ul><li>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li><li>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li></ul><h3 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h3><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul><h3 id="mysql-问题排查都有哪些手段"><a href="#mysql-问题排查都有哪些手段" class="headerlink" title="mysql 问题排查都有哪些手段"></a>mysql 问题排查都有哪些手段</h3><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li>使用 explain 命令查询 SQL 语句执行计划。</li><li>开启慢查询日志，查看慢查询的 SQL。</li></ul><h3 id="如何做-mysql-的性能优化"><a href="#如何做-mysql-的性能优化" class="headerlink" title="如何做 mysql 的性能优化"></a>如何做 mysql 的性能优化</h3><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li>垂直分割分表。</li><li>选择正确的存储引擎。</li></ul><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><strong>说下原生 JDBC 操作数据库流程？</strong></p><ul><li>第一步：Class.forName() 加载数据库连接驱动；</li><li>第二步：DriverManager.getConnection() 获取数据连接对象;</li><li>第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;</li><li>第四步：执行 SQL，执行 SQL 前如果有参数值就设置参数值 setXXX();</li><li>第五步：处理结果集；</li><li>第六步：关闭结果集、关闭会话、关闭连接。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>数据高并发的读写</li><li>海量数据的读写</li><li>对扩展性要求高的数据</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</li><li>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li></ul><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>string、list、hash、set、zset。</p><h3 id="支持的-java-客户端"><a href="#支持的-java-客户端" class="headerlink" title="支持的 java 客户端"></a>支持的 java 客户端</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h3 id="jedis-和-redisson"><a href="#jedis-和-redisson" class="headerlink" title="jedis 和 redisson"></a>jedis 和 redisson</h3><ul><li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</li><li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h3 id="怎么保证缓存和数据库数据的一致性"><a href="#怎么保证缓存和数据库数据的一致性" class="headerlink" title="怎么保证缓存和数据库数据的一致性"></a>怎么保证缓存和数据库数据的一致性</h3><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。<ul><li>优点：节省磁盘空间，恢复速度快</li><li>缺点：数据庞大时比较消耗性能，Redis 意外 down 掉的话，可能会丢失最后一次快照的所有修改</li></ul></li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。<ul><li>优点：备份机制更稳健，丢失数据概率较低；可读的日志文本，可以处理误操作</li><li>缺点：占用更多的空间；恢复备份速度慢；</li></ul></li></ul><h3 id="redis-怎么实现分布式锁"><a href="#redis-怎么实现分布式锁" class="headerlink" title="redis 怎么实现分布式锁"></a>redis 怎么实现分布式锁</h3><ul><li>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</li><li>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</li></ul><h3 id="redis-分布式锁有什么缺陷"><a href="#redis-分布式锁有什么缺陷" class="headerlink" title="redis 分布式锁有什么缺陷"></a>redis 分布式锁有什么缺陷</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h3 id="redis-如何做内存优化"><a href="#redis-如何做内存优化" class="headerlink" title="redis 如何做内存优化"></a>redis 如何做内存优化</h3><ul><li>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</li><li>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</li></ul><h2 id="Spring-Boot-x2F-Spring-Cloud"><a href="#Spring-Boot-x2F-Spring-Cloud" class="headerlink" title="Spring Boot&#x2F;Spring Cloud"></a>Spring Boot&#x2F;Spring Cloud</h2><h3 id="什么是-spring-boot"><a href="#什么是-spring-boot" class="headerlink" title="什么是 spring boot"></a>什么是 spring boot</h3><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p><h3 id="为什么要用-spring-boot"><a href="#为什么要用-spring-boot" class="headerlink" title="为什么要用 spring boot"></a>为什么要用 spring boot</h3><ul><li>Spring Boot使编码变简单</li><li>Spring Boot使配置变简单</li><li>Spring Boot使部署变简单</li><li>Spring Boot使监控变简单</li></ul><h3 id="什么是-spring-cloud"><a href="#什么是-spring-cloud" class="headerlink" title="什么是 spring cloud"></a>什么是 spring cloud</h3><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架用于对微服务进行治理。</p><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p><h3 id="spring-cloud-断路器的作用是什么"><a href="#spring-cloud-断路器的作用是什么" class="headerlink" title="spring cloud 断路器的作用是什么"></a>spring cloud 断路器的作用是什么</h3><p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p><h3 id="spring-cloud-的核心组件"><a href="#spring-cloud-的核心组件" class="headerlink" title="spring cloud 的核心组件"></a>spring cloud 的核心组件</h3><ul><li>①. 服务发现——Netflix Eureka<br>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</li><li>②. 客服端负载均衡——Netflix Ribbon<br>Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</li><li>③. 断路器——Netflix Hystrix<br>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li><li>④. 服务网关——Netflix Zuul<br>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</li><li>⑤. 分布式配置——Spring Cloud Config<br>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><ul><li>面试官好，我叫 XXX，来自 XXXX 计算机系</li><li>这一次我应聘的是 Java 开发的工作，虽然我是网络工程专业的，但是我对软件开发一直有浓厚的兴趣</li><li>为此，在大学阶段我就结合 Java 开发岗位的要求进行了准备，选修了许多 Java 方面的知识</li><li>同时，我也自学了一些当前比较流行的技术，如 Spring Boot、Spring Cloud 等。</li><li>希望能加入贵公司，从事 Java 开发的工作，谢谢</li></ul><h3 id="薪资"><a href="#薪资" class="headerlink" title="薪资"></a>薪资</h3><p><strong>如果我们给你的工资，没有达到简历上的要求，你还会来吗？</strong></p><ul><li>相比于工资，公司的选择对我来说是更重要的，我更看重公司的发展前景和我在公司的发展平台。</li><li>在我这个年纪呢，我觉得前途比薪水更重要。</li><li>再说了，我相信只要我的能力达到贵公司的要求，你们不会给我比别人低的工资。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Janvy Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://janvysun.github.io/java/48704b01-97d8-4702-a476-d9e013ac36c2.html">https://janvysun.github.io/java/48704b01-97d8-4702-a476-d9e013ac36c2.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://janvysun.github.io" target="_blank">Janvy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/images/hexo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/java/cc356c4a-ea8c-4755-bd96-b982473795f6.html"><img class="prev-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 笔试题</div></div></a></div><div class="next-post pull-right"><a href="/ubuntu/3bd23daf-2dec-409d-91bd-921eb3c755eb.html"><img class="next-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ubuntu 常用设置</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/cas/0fe101e5-0ba8-44d8-b7fc-db6875378f8b.html" title="CAS 工程搭建"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-18</div><div class="title">CAS 工程搭建</div></div></a></div><div><a href="/cas/65b185fc-a46c-49b6-b2f2-f748091f9153.html" title="CAS JDBC 认证"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-22</div><div class="title">CAS JDBC 认证</div></div></a></div><div><a href="/cas/d68e34ba-c74d-4baa-9fe0-0398e2fc43d3.html" title="CAS JDBC 认证"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-20</div><div class="title">CAS JDBC 认证</div></div></a></div><div><a href="/cas/92daec4f-439d-4de2-b0ed-2657648bd351.html" title="CAS 自定义认证策略"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-24</div><div class="title">CAS 自定义认证策略</div></div></a></div><div><a href="/cas/b9219ed5-c752-450b-b0f6-ed7e4724e49d.html" title="CAS 自定义主题"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-26</div><div class="title">CAS 自定义主题</div></div></a></div><div><a href="/cas/ec5c828d-71a0-4717-80bf-2e7ab016dcfc.html" title="CAS 自定义表单"><img class="cover" src="/images/hexo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-28</div><div class="title">CAS 自定义表单</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Janvy Sun</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/janvysun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:janvusun@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E5%92%8C-JRE"><span class="toc-number">1.1.</span> <span class="toc-text">JDK 和 JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.2.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.3.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-%E3%80%81-amp-amp"><span class="toc-number">1.4.</span> <span class="toc-text">&amp;、&amp;&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.5.</span> <span class="toc-text">多重循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Files"><span class="toc-number">1.8.</span> <span class="toc-text">Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.9.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">1.11.</span> <span class="toc-text">对象克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.12.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.13.</span> <span class="toc-text">JDK 8 新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">多态机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">异常种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E3%80%81Exception"><span class="toc-number">3.2.</span> <span class="toc-text">Error、Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E3%80%81throws"><span class="toc-number">3.3.</span> <span class="toc-text">throw、throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">常见的异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="toc-number">4.</span> <span class="toc-text">常用 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">4.1.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">4.2.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">5.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.</span> <span class="toc-text">流之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">5.2.</span> <span class="toc-text">BIO、NIO、AIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">Java 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E5%92%8C-Collections"><span class="toc-number">6.1.</span> <span class="toc-text">Collection 和 Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E3%80%81Set%E3%80%81Map"><span class="toc-number">6.2.</span> <span class="toc-text">List、Set、Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">6.3.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">6.4.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">HashMap 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.6.</span> <span class="toc-text">HashSet 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C-List-%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.7.</span> <span class="toc-text">数组和 List 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-%E5%92%8C-ArrayList"><span class="toc-number">6.8.</span> <span class="toc-text">Array 和 ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">6.9.</span> <span class="toc-text">线程安全的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E4%B8%AD%E7%9A%84-null"><span class="toc-number">6.10.</span> <span class="toc-text">Map 中的 null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator"><span class="toc-number">6.11.</span> <span class="toc-text">Iterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">7.1.</span> <span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">程序运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable-%E5%92%8C-callable"><span class="toc-number">7.5.</span> <span class="toc-text">runnable 和 callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">7.6.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-wait-yield-join"><span class="toc-number">7.7.</span> <span class="toc-text">sleep(),wait(),yield(),join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-notifyAll"><span class="toc-number">7.8.</span> <span class="toc-text">notify(),notifyAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-start"><span class="toc-number">7.9.</span> <span class="toc-text">run(),start()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.10.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#submit-execute"><span class="toc-number">7.11.</span> <span class="toc-text">submit(),execute()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">7.12.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">8.1.</span> <span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">怎么防止死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">8.4.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">8.5.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">8.6.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">atomic 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.8.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">9.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90"><span class="toc-number">9.1.</span> <span class="toc-text">主要组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">堆栈区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">9.4.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">9.5.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-number">9.6.</span> <span class="toc-text">双亲委派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">9.7.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">9.8.</span> <span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">9.9.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%9E%83%E5%9C%BE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.10.</span> <span class="toc-text">找垃圾的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">9.11.</span> <span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3-GC-%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">9.12.</span> <span class="toc-text">分代 GC 工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STW"><span class="toc-number">9.13.</span> <span class="toc-text">STW</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Web"><span class="toc-number">10.</span> <span class="toc-text">Java Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet"><span class="toc-number">10.1.</span> <span class="toc-text">Servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP"><span class="toc-number">10.2.</span> <span class="toc-text">JSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.3.</span> <span class="toc-text">jsp 内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp-%E7%9A%84-4-%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.4.</span> <span class="toc-text">jsp 的 4 种作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">10.6.</span> <span class="toc-text">MVC 设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E6%B5%81%E7%A8%8B"><span class="toc-number">10.7.</span> <span class="toc-text">JDBC 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-%E5%92%8C-cookie"><span class="toc-number">10.8.</span> <span class="toc-text">session 和 cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.9.</span> <span class="toc-text">session 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-sql-%E6%B3%A8%E5%85%A5"><span class="toc-number">10.10.</span> <span class="toc-text">如何避免 sql 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">10.11.</span> <span class="toc-text">XSS 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB"><span class="toc-number">10.12.</span> <span class="toc-text">CSRF 攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">11.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%93%8D%E5%BA%94%E7%A0%81"><span class="toc-number">11.1.</span> <span class="toc-text">http 响应码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS"><span class="toc-number">11.2.</span> <span class="toc-text">HTTP 和 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.3.</span> <span class="toc-text">长连接、短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-%E5%92%8C-redirect"><span class="toc-number">11.4.</span> <span class="toc-text">forward 和 redirect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E5%92%8C-udp"><span class="toc-number">11.5.</span> <span class="toc-text">tcp 和 udp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">11.6.</span> <span class="toc-text">tcp 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.7.</span> <span class="toc-text">OSI 七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%92%8C-post"><span class="toc-number">11.8.</span> <span class="toc-text">get 和 post</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-x2F-Spring-MVC"><span class="toc-number">12.</span> <span class="toc-text">Spring &#x2F; Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-spring"><span class="toc-number">12.1.</span> <span class="toc-text">为什么要使用 spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-number">12.2.</span> <span class="toc-text">Spring 能干什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory"><span class="toc-number">12.3.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">12.4.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">12.5.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97"><span class="toc-number">12.6.</span> <span class="toc-text">spring 主要模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">12.7.</span> <span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.8.</span> <span class="toc-text">Bean 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">12.9.</span> <span class="toc-text">Bean 的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.10.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">12.11.</span> <span class="toc-text">事务属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB"><span class="toc-number">12.12.</span> <span class="toc-text">事务隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smvc-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">12.13.</span> <span class="toc-text">Smvc 运行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smvc-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">12.14.</span> <span class="toc-text">Smvc 有哪些组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81"><span class="toc-number">12.15.</span> <span class="toc-text">中文乱码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">12.16.</span> <span class="toc-text">拦截器、过滤器、监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.17.</span> <span class="toc-text">常用注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis"><span class="toc-number">13.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ORM"><span class="toc-number">13.1.</span> <span class="toc-text">ORM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.2.</span> <span class="toc-text">#{}和 ${}的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.3.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8E%E8%A1%A8%E5%90%8D%E4%B8%8D%E5%90%8C"><span class="toc-number">13.4.</span> <span class="toc-text">字段名与表名不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">13.5.</span> <span class="toc-text">延迟加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">13.6.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%88Executor%EF%BC%89"><span class="toc-number">13.7.</span> <span class="toc-text">执行器（Executor）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">14.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">14.1.</span> <span class="toc-text">三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID"><span class="toc-number">14.2.</span> <span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char-%E5%92%8C-varchar"><span class="toc-number">14.3.</span> <span class="toc-text">char 和 varchar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float-%E5%92%8C-double"><span class="toc-number">14.4.</span> <span class="toc-text">float 和 double</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5"><span class="toc-number">14.5.</span> <span class="toc-text">内连接、左连接、右连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">14.6.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-1"><span class="toc-number">14.7.</span> <span class="toc-text">事务隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E"><span class="toc-number">14.8.</span> <span class="toc-text">常用引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81"><span class="toc-number">14.9.</span> <span class="toc-text">行锁和表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E6%AE%B5"><span class="toc-number">14.10.</span> <span class="toc-text">mysql 问题排查都有哪些手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-mysql-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">14.11.</span> <span class="toc-text">如何做 mysql 的性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC"><span class="toc-number">14.12.</span> <span class="toc-text">JDBC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">15.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">15.3.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">15.4.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.5.</span> <span class="toc-text">支持的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84-java-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">15.6.</span> <span class="toc-text">支持的 java 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis-%E5%92%8C-redisson"><span class="toc-number">15.7.</span> <span class="toc-text">jedis 和 redisson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">15.8.</span> <span class="toc-text">怎么保证缓存和数据库数据的一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">15.9.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">15.10.</span> <span class="toc-text">redis 怎么实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="toc-number">15.11.</span> <span class="toc-text">redis 分布式锁有什么缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">15.12.</span> <span class="toc-text">redis 如何做内存优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-x2F-Spring-Cloud"><span class="toc-number">16.</span> <span class="toc-text">Spring Boot&#x2F;Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot"><span class="toc-number">16.1.</span> <span class="toc-text">什么是 spring boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-spring-boot"><span class="toc-number">16.2.</span> <span class="toc-text">为什么要用 spring boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-cloud"><span class="toc-number">16.3.</span> <span class="toc-text">什么是 spring cloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-cloud-%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">16.4.</span> <span class="toc-text">spring cloud 断路器的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-cloud-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">16.5.</span> <span class="toc-text">spring cloud 的核心组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">17.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">17.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%96%AA%E8%B5%84"><span class="toc-number">17.2.</span> <span class="toc-text">薪资</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="世界が終るまでは…"></a><div class="content"><a class="title" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…">世界が終るまでは…</a><time datetime="2024-04-20T16:00:00.000Z" title="发表于 2024-04-21 00:00:00">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="我的世界攻略"></a><div class="content"><a class="title" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略">我的世界攻略</a><time datetime="2024-03-31T16:00:00.000Z" title="发表于 2024-04-01 00:00:00">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Nginx 的安装与使用"></a><div class="content"><a class="title" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用">Nginx 的安装与使用</a><time datetime="2024-03-10T16:00:00.000Z" title="发表于 2024-03-11 00:00:00">2024-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="真三国无双 7 攻略"></a><div class="content"><a class="title" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略">真三国无双 7 攻略</a><time datetime="2024-02-29T16:00:00.000Z" title="发表于 2024-03-01 00:00:00">2024-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker Compose 使用"></a><div class="content"><a class="title" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用">Docker Compose 使用</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By Janvy Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>