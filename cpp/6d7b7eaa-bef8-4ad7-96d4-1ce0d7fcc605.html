<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程 - 条件变量 condition_variable | Janvy's blog</title><meta name="keywords" content="并发编程"><meta name="author" content="Janvy Sun"><meta name="copyright" content="Janvy Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍 C++ 并发编程中的条件变量 condition_variable"><meta property="og:type" content="article"><meta property="og:title" content="并发编程 - 条件变量 condition_variable"><meta property="og:url" content="https://janvysun.github.io/cpp/6d7b7eaa-bef8-4ad7-96d4-1ce0d7fcc605.html"><meta property="og:site_name" content="Janvy&#39;s blog"><meta property="og:description" content="本文介绍 C++ 并发编程中的条件变量 condition_variable"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://janvysun.github.io/images/hexo.png"><meta property="article:published_time" content="2023-11-02T16:00:00.000Z"><meta property="article:modified_time" content="2023-11-02T16:00:00.000Z"><meta property="article:author" content="Janvy Sun"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://janvysun.github.io/images/hexo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://janvysun.github.io/cpp/6d7b7eaa-bef8-4ad7-96d4-1ce0d7fcc605"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: [object Object]
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程 - 条件变量 condition_variable",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-11-03 00:00:00"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background:linear-gradient(20deg,#0062be,#925696,#cc426e,#fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Janvy's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程 - 条件变量 condition_variable</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-02T16:00:00.000Z" title="发表于 2023-11-03 00:00:00">2023-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-02T16:00:00.000Z" title="更新于 2023-11-03 00:00:00">2023-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="并发编程 - 条件变量 condition_variable"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在多线程编程中，有一种十分常见的行为：线程同步。线程同步是指线程间需要按照预定的先后次序顺序进行的行为。C++11 对这种行为也提供了有力的支持，这就是<strong>条件变量</strong>。条件变量位于头文件 <code>condition_variable</code> 下。</p><p>condition_variable&#x2F;condition_variable_any类是一个synchronization primitive，可用于阻止一个线程或同时阻止多个线程，直到另一个线程修改共享变量（condition），并通知condition_variable，才会继续执行。</p><p>当调用它的wait函数时，它使用一个mutex来锁定线程。使得该线程保持阻塞状态，直到被另一个线程调用同一个condition_variable对象上的notify函数才被唤醒。condition_variable类型的对象必须使用unique_lock<mutex>等待，而 std::condition_variable_any可以跟任何其他可锁定对象绑定使用, 也可以使用自定义类型。</mutex></p><p>其实，条件变量跟 cpp11 没特别大关系，它是操作系统实现的（Linux下使用 pthread库中的 pthread_cond_*() 函数提供了与条件变量相关的功能）。现在的关键在于理解为啥要有它，而且需注意一点，条件变量自身并不包含条件。因为它通常和 if (或者while) 一起用，所以叫条件变量。</p><p>并发有两大需求，一是互斥，二是等待(同步)。互斥是因为线程间存在共享数据，等待则是因为线程间存在依赖。互斥的话，通过互斥锁能搞定，常见的有依赖操作系统的 mutex。条件变量，是为了解决等待需求。考虑实现生产者消费者队列，生产者和消费者各是一个线程。一个明显的依赖是，消费者线程依赖生产者线程 push 元素进队列。没有条件变量，你会怎么实现消费者呢？让消费者线程一直轮询队列（需要加 mutex)。如果是队列里有值，就去消费；如果为空，要么是继续查，要么sleep一下，让系统过一会再唤醒你，你再次查。可以想到，无论哪种策略，都不通用，要么费cpu，要么线程过分sleep，影响该线程的性能。</p><p>有条件变量后，你就可以用事件模式了。上面的消费者线程，发现队列为空，就告诉操作系统，我要wait，一会肯定有其他线程发信号来唤醒我的。这个其他线程，实际上就是生产者线程。生产者线程push队列之后，则调用signal，告诉操作系统，之前有个线程在wait，你现在可以唤醒它了。上述两种等待方式，前者是轮询(poll)，后者是事件(event)。一般来说，事件方式比较通用，性能不会太差(但存在切换上下文的开销)。轮询方式的性能，就非常依赖并发pattern，也特别消耗cpu。</p><p>条件变量要和锁一起使用，锁提供了互斥这一机制，而条件变量在其基础上提供了同步的机制（同步是比互斥更严格的关系，互斥只要求线程间访问某一资源时不存在同时处理或者交替处理的可能，而对线程本身的调度顺序没有限制，也就是说谁先访问都行但你们一个个来，这就是互斥。同步就是在互斥的基础上，虽然线程之间的调度我们没办法控制，但我们可以原子的让某些线程在唤醒时检查某个条件，如果条件不满足就释放锁然后进入阻塞，通过这种方式达到控制不同线程按照某一种你设定的顺序访问资源）。一般条件变量，锁和用户提供的判定条件这三个因素一起组合使用，上文中的某个条件就是指用户提供的判定条件，而线程在检查这个条件，如果不满足就释放锁然后进入阻塞这个过程的原子性由条件变量提供，这也是条件变量的意义。</p><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>今天的目的，我们不介绍系统的条件变量，今天介绍 C++11 的 condition_variable。先来简单介绍一下它的主要成员函数。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程的执行会被阻塞，直到收到 notify 为止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程仅在 pred=false 时阻塞；如果 pred=true 时，不阻塞。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>wait 会阻塞当前线程直至条件变量被通知，或虚假唤醒发生。</p><p>调用 wait 时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。然后阻塞当前执行线程，另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数再次调用 lck.lock() 重新上锁然后 wait 返回退出，可以理解 lck 的状态变换和 wait 函数被调用(退出)是同时进行的。</p><p>std::condition_variable 提供了两种 wait() 函数。第二种情况多了条件参数 Predicate，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) &#123;</span><br><span class="line">    <span class="built_in">wait</span>(unique_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unblocks当前正在等待此条件的一个线程。</span></span><br><span class="line"><span class="comment">// 如果没有线程在等待，则函数不执行任何操作。</span></span><br><span class="line"><span class="comment">// 如果有多个线程在等待，它不会指定具体哪个线程。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unblocks当前等待此条件的所有线程。</span></span><br><span class="line"><span class="comment">// 如果没有线程在等待，则函数不执行任何操作。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>notify_one 唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒的线程是不确定的(unspecified)。notify_all 则是唤醒所有在等待的线程。如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(l, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> done_; &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(l, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> done_; &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m_)</span></span>;</span><br><span class="line">      done_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::mutex m_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  <span class="type">bool</span> done_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;A::wait2, &amp;a)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;A::wait1, &amp;a)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(&amp;A::signal, &amp;a)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;  <span class="comment">// 12 or 21</span></span><br></pre></td></tr></table></figure><h3 id="wait-for"><a href="#wait-for" class="headerlink" title="wait_for"></a>wait_for</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">                         </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">               Predicate pred)</span></span>;                   </span><br></pre></td></tr></table></figure><p>wait_for 导致当前线程阻塞直至条件变量被通知，或虚假唤醒发生，或者超时返回。</p><p>返回值说明：</p><ul><li>若经过 rel_time 所指定的关联时限则为 std::cv_status::timeout ，否则为 std::cv_status::no_timeout 。</li><li>若经过 rel_time 时限后谓词 pred 仍求值为 false 则为 false ，否则为 true 。</li></ul><p>以上两个类型的 wait 函数都在会阻塞时，自动释放锁权限，即调用 unique_lock 的成员函数 unlock()，以便其他线程能有机会获得锁。这就是条件变量只能和 unique_lock 一起使用的原因，否则当前线程一直占有锁，线程被阻塞。</p><p>与 std::condition_variable::wait() 类似，不过 wait_for 可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for返回，剩下的处理步骤和 wait()类似。</p><p>另外，wait_for 的重载版本的最后一个参数pred表示 wait_for的预测条件，只有当 pred条件为false时调用 wait()才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred为 true时才会被解除阻塞，因此相当于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait_for</span>(lock, rel_time) == std::cv_status::timeout) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pred</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="wait-until"><a href="#wait-until" class="headerlink" title="wait_until"></a>wait_until</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</span></span><br><span class="line"><span class="function">std::cv_status</span></span><br><span class="line"><span class="function">    <span class="title">wait_until</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration, <span class="keyword">class</span> Pred &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Pred pred )</span></span>;</span><br></pre></td></tr></table></figure><p>wait_until 导致当前线程阻塞直至通知条件变量、抵达指定时间或虚假唤醒发生，可选的循环直至满足某谓词。</p><p>与 std::condition_variable::wait_for 类似，但是wait_until可以指定一个时间点，在当前线程收到通知或者指定的时间点 abs_time超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_until返回，剩下的处理步骤和 wait_until() 类似。</p><p>另外，wait_until 的重载版本的最后一个参数 pred表示 wait_until 的预测条件，只有当 pred条件为 false时调用 wait()才会阻塞当前线程，并且在收到其他线程的通知后只有当pred为 true时才会被解除阻塞，因此相当于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait_for</span>(lock, rel_time) == std::cv_status::timeout) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pred</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="cv-status"><a href="#cv-status" class="headerlink" title="cv_status"></a>cv_status</h3><p>枚举类型，指示函数是否由于超时而返回。该类型是condition_variable和condition_variable_any对象中函数wait_for和wait_until的返回类型。</p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">cv_status</span> &#123; no_timeout, timeout &#125;;</span><br></pre></td></tr></table></figure><ul><li>cv_status::no_timeout ：函数在规定时间内返回（例如：被notufy_*唤醒）。</li><li>cv_status::timeout：函数因超时返回。</li></ul><h3 id="wait-内部实现"><a href="#wait-内部实现" class="headerlink" title="wait 内部实现"></a>wait 内部实现</h3><p>下面用 condition_variable_any 来举个例子简单说明一下 wait 函数内部调用的流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> now = steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;lock: &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> now = steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;unlock: &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;notify_one start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();  <span class="comment">// 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;notify_one end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mutex m;</span><br><span class="line">    <span class="keyword">auto</span> now = steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wait start: &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(now).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(m);  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">auto</span> end = steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wait end: &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(end).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::condition_variable_any cv_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;A::signal, &amp;a)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;A::wait, &amp;a)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;  <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>语句①，我们先让signal线程等待一段时间(1s)再唤醒wait线程；</p><p>语句③调用wait函数会阻塞，大概会阻塞1s钟，但是阻塞前自动释放锁权限，即调用Mutex的成员函数unlock()，当有其他线程notify(语句②)后wait函数返回，重新调用Mutex的成员函数lock()。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wait start: 21447210   // 1</span><br><span class="line">unlock: 21447210       // 2</span><br><span class="line">notify_one start</span><br><span class="line">notify_one end</span><br><span class="line">lock: 21448210         // 3</span><br><span class="line">wait end: 21448210     // 4</span><br></pre></td></tr></table></figure><p>从上面的输出也可以看出，语句①和②是几乎同时发生的，也就是调用wait时condition_variable_any会立刻unlock，而当wait返回时则时调用lock，从语句③和④可以得知。</p><h3 id="condition-variable-any"><a href="#condition-variable-any" class="headerlink" title="condition_variable_any"></a>condition_variable_any</h3><p>与 std::condition_variable类似，只不过std::condition_variable_any的 wait 函数可以接受任何 lockable参数，而 std::condition_variable只能接受 std::unique_lock类型的参数，除此以外，和std::condition_variable几乎完全一样。</p><p>std::condition_variable_any 能与std::shared_lock一同使用，在std::shared_mutex上以共享所有权模式等待。</p><p>condition_variable_any 类是std::condition_variable的泛化。相对于只在std::unique_lock<a href="std::mutex">std::mutex</a>上工作的std::condition_variable ， condition_variable_any 能在任何满足基本可锁定 (BasicLockable) 要求的锁上工作(也可用于自定义可锁定的类型)。</p><p>类 std::condition_variable_any 是标准布局类型 (StandardLayoutType) 。它非可复制构造 (CopyConstructible) 、可移动构造 (MoveConstructible) 、可复制赋值 (CopyAssignable) 或可移动赋值 (MoveAssignable) 。</p><p>若锁是 std::unique_lock，结合 std::condition_variable 可能会有更好的性能。</p><h3 id="notify-all-at-thread-exit"><a href="#notify-all-at-thread-exit" class="headerlink" title="notify_all_at_thread_exit"></a>notify_all_at_thread_exit</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">( std::condition_variable&amp; cond, std::unique_lock&lt;std::mutex&gt; lk )</span></span>;</span><br></pre></td></tr></table></figure><p>notify_all_at_thread_exit 提供机制，通知其他线程给定的线程已完全完成，包括已经销毁所有thread_local资源。它操作如下：</p><ul><li>将先前获得的锁 lk 的所有权转移到内部存储。</li><li>修改执行环境，以令当前线程退出时，如同以下列方式通知 condition_variable cond ：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lk.<span class="built_in">unlock</span>();</span><br><span class="line">cond.<span class="built_in">notify_all</span>();</span><br></pre></td></tr></table></figure><p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知。请看下例（参考）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!ready) cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  std::<span class="built_in">notify_all_at_thread_exit</span>(cv,std::<span class="built_in">move</span>(lck));</span><br><span class="line">  ready = <span class="literal">true</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ready = true &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = std::<span class="built_in">thread</span>(print_id, i);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  std::<span class="built_in">thread</span>(go).<span class="built_in">detach</span>();   <span class="comment">// go!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 threads ready to race...</span><br><span class="line">ready = true </span><br><span class="line">thread 6</span><br><span class="line">thread 7</span><br><span class="line">thread 9</span><br><span class="line">thread 8</span><br><span class="line">thread 5</span><br><span class="line">thread 4</span><br><span class="line">thread 3</span><br><span class="line">thread 2</span><br><span class="line">thread 1</span><br><span class="line">thread 0</span><br></pre></td></tr></table></figure><h2 id="唤醒丢失"><a href="#唤醒丢失" class="headerlink" title="唤醒丢失"></a>唤醒丢失</h2><p>唤醒丢失：唤醒丢失的现象是发送方在接收方进入等待状态之前发送通知。结果就是导致通知消失。C++标准以同时同步机制描述条件变量，“条件变量类是原始的，可同步的用于阻塞单个或多个线程，…”, 因此，当通知丢失后，接受方将一直处于等待状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex lock;</span><br><span class="line">std::condition_variable condVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingForWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(lock)</span></span>;</span><br><span class="line">    condVar.<span class="built_in">wait</span>(l);                                     <span class="comment">//(1)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDataReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data prepared, notify one&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    condVar.<span class="built_in">notify_one</span>();                                <span class="comment">//(2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==========Begin==========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingForWork)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(setDataReady)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===========End===========&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中的 wait 的调用没有使用谓词，这样的同步看起来相当的简单。但是遗憾的是，这中情况会导致唤醒丢失。此处出现的唤醒丢失导致了死锁。</p><p>如果 wait 调用使用了谓词，则不会出现唤醒丢失的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::mutex lock;</span><br><span class="line">std::condition_variable condVar;</span><br><span class="line"><span class="type">bool</span> dataReady&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingForWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(lock)</span></span>;</span><br><span class="line">    condVar.<span class="built_in">wait</span>(l, []&#123;<span class="keyword">return</span> dataReady;&#125;); <span class="comment">// 使用谓词</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDataReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; l&#123;lock&#125;;</span><br><span class="line">        dataReady = <span class="literal">true</span>;   <span class="comment">// 将谓词状态设置为 true，注意这个谓词是线程间共同使用的全局变量，设置时需要加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data prepared, notify one&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    condVar.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意：收发方都需要同一把锁，对于发送着来说，使用 std::lock_guard 已经足够了，因为它只调用一次 lock 和 unlock,而对于接收者，必须使用 std::unique_lock, 因为频繁多次的 lock 和 unlock。</p><p>wait工作流程：</p><ol><li>在等待的初始处理中，该线程先锁定互斥锁，然后检查谓词 []{return dataReady;} （谓词：在计算机语言的环境下，谓词是指条件表达式的求值返回真或假的过程。）<br>如果谓词被评估为：<ul><li>true: 线程继续工作</li><li>false: condVar.wait()解锁互斥并将线程置于等待（阻塞）状态</li></ul></li><li>如果条件变量 condVar 处于等待状态并收到通知或被虚假唤醒，则会发生下面步骤：<ul><li>线程被解除阻塞，并重新获得互斥锁</li><li>线程检查谓词，如果谓词被评估为：<ul><li>true: 线程继续其工作</li><li>false: condVar.wait()解锁互斥并将线程置于等待（阻塞）状态</li></ul></li></ul></li></ol><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>我们上面提到很多次虚假唤醒，这里详细解释一下。其实在正常情况下，wait 类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait 类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的 wait 函数，因为这种(xxx, Predicate pred )类型的函数等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) <span class="comment">//while循环，解决了虚假唤醒的问题</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设系统不存在虚假唤醒的时，代码只要像下面这样写就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (不满足条件) &#123;</span><br><span class="line">    <span class="comment">//没有虚假唤醒，wait 函数可以一直等待，直到被唤醒或者超时，没有问题。</span></span><br><span class="line">    <span class="comment">//但实际中却存在虚假唤醒，导致假设不成立，wait不会持续等待，会跳出if语句，</span></span><br><span class="line">    <span class="comment">//提前执行其他代码，流程异常</span></span><br><span class="line">    <span class="built_in">wait</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但因为存在虚假唤醒，所以，正确的方式应该是使用 while 语句来解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!(xxx条件) ) &#123;</span><br><span class="line">    <span class="comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span></span><br><span class="line">    <span class="comment">//否则继续等待，解决虚假唤醒</span></span><br><span class="line">    <span class="built_in">wait</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量使用"><a href="#条件变量使用" class="headerlink" title="条件变量使用"></a>条件变量使用</h2><p>下面我们使用一个经典的生产者-消费者场景来阐述对于condition_variable的使用，生产者-消费者问题，也称有限缓冲问题，是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”,在实际运行时会发生的问题。</p><p>生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_cvMutex;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存区</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; g_data_deque;</span><br><span class="line"><span class="comment">//缓存区最大数目</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  MAX_NUM = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="type">int</span> g_next_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者，消费者线程个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PRODUCER_THREAD_NUM  = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CONSUMER_THREAD_NUM = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">producer_thread</span><span class="params">(<span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">         <span class="comment">//加锁</span></span><br><span class="line">         std::unique_lock &lt;std::mutex&gt; <span class="built_in">lk</span>(g_cvMutex);</span><br><span class="line">         <span class="comment">//当队列未满时，继续添加数据</span></span><br><span class="line">         g_cv.<span class="built_in">wait</span>(lk, []()&#123; <span class="keyword">return</span> g_data_deque.<span class="built_in">size</span>() &lt;= MAX_NUM; &#125;);</span><br><span class="line">         g_next_index++;</span><br><span class="line">         g_data_deque.<span class="built_in">push_back</span>(g_next_index);</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;producer_thread: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; producer data: &quot;</span> &lt;&lt; g_next_index;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot; queue size: &quot;</span> &lt;&lt; g_data_deque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">         <span class="comment">//唤醒其他线程 </span></span><br><span class="line">         g_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">     &#125;  <span class="comment">//自动释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">consumer_thread</span><span class="params">(<span class="type">int</span> thread_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">550</span>));</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; <span class="built_in">lk</span>(g_cvMutex);</span><br><span class="line">        <span class="comment">//检测条件是否达成</span></span><br><span class="line">        g_cv.<span class="built_in">wait</span>( lk,   []&#123; <span class="keyword">return</span> !g_data_deque.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        <span class="comment">//互斥操作，消息数据</span></span><br><span class="line">        <span class="type">int</span> data = g_data_deque.<span class="built_in">front</span>();</span><br><span class="line">        g_data_deque.<span class="built_in">pop_front</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\tconsumer_thread: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="string">&quot; consumer data: &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; <span class="string">&quot; deque size: &quot;</span> &lt;&lt; g_data_deque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//唤醒其他线程</span></span><br><span class="line">        g_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;  <span class="comment">//自动释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread arrRroducerThread[PRODUCER_THREAD_NUM];</span><br><span class="line">    std::thread arrConsumerThread[CONSUMER_THREAD_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PRODUCER_THREAD_NUM; i++) &#123;</span><br><span class="line">        arrRroducerThread[i] = std::<span class="built_in">thread</span>(producer_thread, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_THREAD_NUM; i++) &#123;</span><br><span class="line">        arrConsumerThread[i] = std::<span class="built_in">thread</span>(consumer_thread, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PRODUCER_THREAD_NUM; i++) &#123;</span><br><span class="line">        arrRroducerThread[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_THREAD_NUM; i++) &#123;</span><br><span class="line">        arrConsumerThread[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>想要修改共享变量（即“条件”）的线程必须：<br>（1）. 获得一个std::mutex<br>（2）. 当持有锁的时候，执行修改动作<br>（3）. 对std::condition_variable执行notify_one或notify_all(当做notify动作时，不必持有锁)</p><p>即使共享变量是原子性的，它也必须在mutex的保护下被修改，这是为了能够将改动正确发布到正在等待的线程。</p><p>任意要等待std::condition_variable的线程必须：<br>（1）. 获取std::unique_lock<a href="std::mutex">std::mutex</a>，这个mutex正是用来保护共享变量（即“条件”）的<br>（2）. 执行wait, wait_for或者wait_until. 这些等待动作原子性地释放mutex，并使得线程的执行暂停<br>（3）. 当获得条件变量的通知，或者超时，或者一个虚假的唤醒，那么线程就会被唤醒，并且获得mutex. 然后线程应该检查条件是否成立，如果是虚假唤醒，就继续等待。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Janvy Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://janvysun.github.io/cpp/6d7b7eaa-bef8-4ad7-96d4-1ce0d7fcc605.html">https://janvysun.github.io/cpp/6d7b7eaa-bef8-4ad7-96d4-1ce0d7fcc605.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://janvysun.github.io" target="_blank">Janvy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/images/hexo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/docker/4568615f-b040-4c43-a786-990edf668f26.html"><img class="prev-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker 数据卷</div></div></a></div><div class="next-post pull-right"><a href="/cpp/80bf8629-5bde-42f5-aec7-40f4c2996dc8.html"><img class="next-cover" src="/images/hexo.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ Doxygen 注释规范</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Janvy Sun</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/janvysun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:janvusun@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-variable"><span class="toc-number">2.</span> <span class="toc-text">condition_variable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.1.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify"><span class="toc-number">2.2.</span> <span class="toc-text">notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-for"><span class="toc-number">2.3.</span> <span class="toc-text">wait_for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-until"><span class="toc-number">2.4.</span> <span class="toc-text">wait_until</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cv-status"><span class="toc-number">2.5.</span> <span class="toc-text">cv_status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">wait 内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-variable-any"><span class="toc-number">2.7.</span> <span class="toc-text">condition_variable_any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-all-at-thread-exit"><span class="toc-number">2.8.</span> <span class="toc-text">notify_all_at_thread_exit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.</span> <span class="toc-text">唤醒丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-number">4.</span> <span class="toc-text">虚假唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">条件变量使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="世界が終るまでは…"></a><div class="content"><a class="title" href="/lyrics/1f1e25e2-0756-4881-9cc2-b146d03c0ae6.html" title="世界が終るまでは…">世界が終るまでは…</a><time datetime="2024-04-20T16:00:00.000Z" title="发表于 2024-04-21 00:00:00">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="我的世界攻略"></a><div class="content"><a class="title" href="/games/bdac0118-3bf7-43f9-9856-142e616b1ca4.html" title="我的世界攻略">我的世界攻略</a><time datetime="2024-03-31T16:00:00.000Z" title="发表于 2024-04-01 00:00:00">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Nginx 的安装与使用"></a><div class="content"><a class="title" href="/elk/3d7c2057-e448-4b83-a185-8d98e973490e.html" title="Nginx 的安装与使用">Nginx 的安装与使用</a><time datetime="2024-03-10T16:00:00.000Z" title="发表于 2024-03-11 00:00:00">2024-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="真三国无双 7 攻略"></a><div class="content"><a class="title" href="/games/967c02f7-0d5e-4dd8-a2e0-70c97840fc5d.html" title="真三国无双 7 攻略">真三国无双 7 攻略</a><time datetime="2024-02-29T16:00:00.000Z" title="发表于 2024-03-01 00:00:00">2024-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用"><img src="/images/hexo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker Compose 使用"></a><div class="content"><a class="title" href="/docker/4c765195-289e-4cc4-88fb-12d9bb5fed61.html" title="Docker Compose 使用">Docker Compose 使用</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By Janvy Sun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>